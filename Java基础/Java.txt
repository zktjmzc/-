0、IDEA的快捷键：                   Ctrl+D 删除当前行
                           Ctrl+Alt+↓ 复制当前行，并立即粘贴到下一行
                           Ctrl+/ 添加注释，第二次按时结束注释，注意这里注释是直接占一行，也就是说只要在哪一行使用，哪一行都会变成注释
                           Alt+/ 补全代码
                           Ctrl+Alt+L 快速格式化代码（使代码对齐）
                           shift+F10  运行程序
                           Alt+insert 生成构造器的快捷键（一些类、成员函数之类的东西）
                           Ctrl+B 点击相应的方法，能够直接移动到书写方法的地方
                           .var     在书写的变量后面写上.var ，能够自动分配变量名 

1、编译：Java.Hello.java:有了Java源文件，通过编译器将其编译成JVN可以识别的字节码文件。在该源文件目录下，通过javac编译工具对Hello.java文件进行编译。如果程序没有错误，没有任何提示，会在目录文件夹中生成一个字节码文件，同样可以执行程序
2、注意事项：在一个源文件中只能有一个public类，其他类的个数不限
                    如果源文件中存在一个public类，则该文件的名称为该public类的名称。main	方法可以写在非public类中，指定执行非public类，这样的入口是非public类的main方法
3、转义字符：（1）\t  一个制表位，实现对其的功能（就是符号前后的内容中间会空几格）
                     （2）\n  换行符
                     （3）\\ 在内容中输出“\” 在输出中输入双引号，要在双引号的两个部分前加上\，避免引起误会。单引号也是。
                     （4）\r 回车字符  符号后的内容会直接意义对应的替换掉符号前的内容。
4、文档注释：语法：* javadoc标签  内容（特定符号会有提示）
                     作用：在cmd中可以在输入类名前面加上 -javadoc标签  public类名
5、规范：源文件使用utf-8编码，行宽度不要超过80个字节。
6、相对路径和绝对路径：（1）相对路径：从当前目录开始定位，形成一个路径。
                                    （2）绝对路径：从顶级目录开始定位，形成一个路径。
7、加号的使用：当为两个数据类型的时候，代表的是数学上的加号，如果是两个字符类型或字符串类型，则代表的是拼接。
8、数据类型：基本数据类型（1）整型：byte（1字节），short，int, long.
                     （2）浮点型：double（8） float（4）
                     （3）字符型：char（2）
                     （4）布尔型：true false
                       引用数据类型：类（class）
                                             接口（interface）
                                             数组[]
9、浮点型细节：编译器默认小数的变量为double类型，如果想要使用float类型，在小数后面加上大写的F，不论前面的是float还是double。如果0.1514这样的情况，小数点前面的0可以不写。
                        在浮点类型中：2.7和8.1 /3是不一样的结果，后面一个会是一个接近2.7的数，因为编译器是以精度的方式返回一个值。因此在判断这两个数是否相等的时候，不能直接使用“==”，而是使用Math.abs（两数相减<0.000001)来进行判断
10、科学计数法：5.12e2 表示的是5.12的10的2次方，5.12E-2表示的是5.12除以10的2次方
11、API：是语言编译者给予开发者的一些类和方法。查找具体API是用来干什么的，可以看访问www.matools.com
12、unicode（了解）：一种编码，将世界上的所有字符都纳入其中，每一个字符都有独一无二的编码，因此在Unicode中不存在乱码的情况。但是存在浪费存储空间的问题，所有字符都站两个字节
13、UTF-8：是Unicode的最广泛的实现方式，可以使用1到6个字节
14、布尔类型：语法 boolean 变量名 =true；注意java中的布尔类型只能是true或false，不能是类似于c/c++用0和非零的自然数代替。
15、自动类型转换：java进行赋值或运算时，精度小的会转化为精度大的数据类型。从小到大依次为：char -> int -> long -> float -> double         
                                                                                   byte -> short -> int -> long -> float -> double
   例如，int a='b'（b作为char型自动转化为int型）， double d=80(80作为整型向高精度double转换)   注意：转化可以进行跨级，只要是低精度转向高精度都可以

16、自动类型转换的细节和注意事项：（1）当进行复杂运算时，编译器会自动将所有的变量转化为容量最大的数据类型。例如，int num=10；float sum=num+1.1；这样是错误的，编译器会自动先将num转换成和1.1一样的double数据类型，精度更高，无法赋值给float类型
                                                     （2）（byte，short）和char之间不会进行自动转换，即其中一个数据类型的变量不能赋值给另一个数据类型的变量。byte能够接纳的数字范围为：-128 到128 
                               （3）byte、short、char三者是可以相互计算的，且计算时会自动转化为int类型，结果也为int类型，因此运算结果不能赋值给这三个类型的变量
                                                     （4）表达式结果的类型自动转化为操作数中精度最高的类型

17、强制类型转换：将高精度数据转化为低精度数据，语法：在数据或者变量名前加上(要转换的类型)。
                            带来的问题：（1）精度的损失，例如小数转化为整数，编译器会直接去掉小数点后的数字，不会取近似值。
                                               （2）数值溢出，当原数据过大，超过了数据类型的最大承载，会出现溢出的情况。
                                               （3）细节：强转采取就近原则，因此在对于运算式的结果进行转换时，应该先将运算式子扩起来
18、基本数据类型和字符串之间的转换：（1）其他类转换为字符串，直接在后面加上 +“” ，例如，int n=15；String sum=n+“”；
                                                         （2）字符串转化为其他类：语法为：int型：Integer.parseInt(字符串名称)；
                                                                                                             short型：Short.parseShort();除了int型外，所有的转化的规则都是：数据类型.parse数据类型();
                                                               此外转化为char型则需要的是string数组的知识，其转化为 n.charAt(0);表示的是n字符串第一个元素
                                                        （3）细节：将字符串转化为其它数据类型时，要确保能够转化成有效的数据，例如不能将“Hello”转化为一个int型
19、算术运算符（与c++基本保持一致）
（1）除法：当两个整数相除时，如10/4,输出的结果为2，除非你用强制类型转换；同时，如果用double或float类型去接受结果，则得到的是2.0。如果是10.0/4得到的结果为2.5，这是由于自动类型转化的云原因。
（2）取模：取模的本质是：a%b=a-a/b*b,
          所以当被除数为正数，除数为负数时，得到的余数为正数。
（3）后置和前置递增或递减：1、java中：int a=1；a=a++;得到的结果为1，而在c/c++中结果为2，这是因为不同编译器对于后置递增和赋值的优先级有所差异，java返回递增前的值，c/c++返回递增后的值（编译器会先创建一个临时变量去接受赋值，之后返回给被赋值的变量，在c/c++中，先递增后赋值给临时变量，最后返回给被赋值对象；而java临时变量接受的是递增前的值，所以返回被赋值对象本身）。
                        2、如果是 int a=1；int n=a++；则输出的结果三种语言保持一致都为1.
20、关系运算符：（1）大于小于，大于等于小于等于，等于和c保持一致。检验是否为类对象，instanceof；例如“hsp”instanceof String；判断“hsp”是否为String类的对象
21、逻辑运算符：！=（不等于），&&（与），||（或），^（异或，和与正好完全相反，例如，a^b，a与b都为加时为真，否则为假）
22、符合运算时系统会自动进行类型转换，例如，byte b=3；b+=2，结果不会报错，因为编译器会将式子变为b=（byte）b+2；
23、三目运算符（细节）：三目运算符返回的结果必须和被赋值的对象数据类型保持一致，

24、标识符的规范：（1）包名：多单词组成时所有字母都小写：aaa.bbb.ccc
                （2）类名、接口名：多单词组成时每个单词首字母大写：Xxx.Yyy
                （3）变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词后首字母大写
                           （4）常量名：所有字母都大写
25、键盘输入：类似于c++中的cin>>,使用前需要先调用相应的包，import java.util.Scanner;创建一个Scanner类，Scanner myScanner(方法名)=new Scanner（system.in）；接收用户输入：String 对象名=myScanner.next();注意char类型应当是
                      myScanner.next().charArt(0); int类型的则是myScanner.nextInt();
26、进制：二进制表示方法：变量以0b开头。八进制：以0开头。十六进制：以0x开头
27、原码、反码、补码：（1）二进制的最高位是符号位：0是正数，1是负数
                                   （2）正数的三码都一样
                                   （3）负数的反码：它的原码符号位不变，其它位取反（0->1,1->0）
                                   （4）0的反码、补码都是0
                    （5）java没有无符号数，也就是说全是有符号的
                                   （6）在计算机运算的时候，都是以补码的方式进行运算的
                                   （7）我们看运算结果的时候，要看它的原码
                                   （8）负数的补码=负数的反码+1 
28、位运算：>>、<<、>>>:算数右移：低位溢出（>>），符号位不变，并用符号位补溢出的高位，本质是除以几次2，例如3>>2，就是3除以2两次，结果为0
                                                       算数左移（<<）：符号位不变，低位补0，与右移相反，本质是乘以2几次
                                                       逻辑右移（>>>）:低位溢出，高位补0
29、程序控制结构：顺序构造、分支控制、循环控制；使用方法均与c++保持一致
30、跳转控制语句（break）：（1）随机数：Math.random()；会输出一个0到1的数字，可以取到0但不能取到1。因此可以在后面进行加减乘除，来控制其随机数的范围。如Math.random()*100，其会出现0到100的数字，其中不包括100，在前面加括号可以调整数据类型
                         （2）break需要注意的细节：在多层嵌套循环中，可以通过在break后面加标签的形式选择性进行暂停，如lable1:for(int i=0;i<100;i++){};lable 2:for(int j=0;j<100;j++){if(j==10){break lable 1)}；代码中lable1会受到break的影响。如果没有指定标签会自动退出最近的标签
                                          （3）continue：结束本次循环，开始下一次循环，嵌套循环也成立。
                                          （4）return：直接跳出所在的方法，如果在主方法中，直接跳出整个循环
31、字符串的比较：可以通过equals来进行比较。具体的方法如下，例如，正确字符串.equals(需要比较的字符串）。

引用数据类型：
1、数组（arry）：(1)基础形式：数据类型 []数组名={1,2,3,4,5}；数组的本质是对象
                获取长度：数组名.length; 
                注意事项：在初始化数组的时候，如果已知数组的长度，可以直接创建一个长度确定的数组，例如，int [] arry1=new int[长度];也可以是   int [] arry2; arry2=new  int [5]
                         在初始化数组的时候，还有一种办法是可行的，当我们知道数组的具体各值的情况下，可以使用 int[] arry3={1,2,3,4};
                (2)数组使用的细节：数组内的元素类型是相同的，数组中的元素可以为任意类型，但是不能进行混用。
                          （3）数组的赋值机制：当一个数组赋值给另一个数组，被赋值的数组放生改变，赋值数组也发生改变，因为数组间的赋值属于值拷贝，会相互之间影响。
                                                           如果想要不相互影响，可以进行先创建一个数组，开辟一个空间，这样就可以避免值拷贝的问题。操作如下：
int[] arr1={1,2,3,4,5}; 
int[] arr2=new[arr1.length];
arr2=arr1;               
for(int i=0;i<arr1.length;i++){
arr[i]=arr[2];
}                                                     

                (4）数组的扩容：先创建一个新的数组，先遍历一遍原数组，将原数组的元素中赋值给新的数组，可以需要添加还是删除，将for循环的长度进行控制，之后再进行添加，后再加新的数组赋值给原来的数组。

2、二维数组：（1）表现的三种形式：已知数组中的元素：int [][]arr={{0,1,2,3,}{4,56,7}};不知道其中元素，但知道行和列的值，int[] [] arr=new int[4][5];先不知道行，但是之后可能会用到，int [] []arr;  //先声明    arr=new int[4][5];
            （2）注意：在java中，二维数组可以不确定列，但是必须确定行；与c++正好相反；在遍历完行之后，要创建每一行的列，否则这一行是什么都没有的，连0都没有；代码如下
   package project;

public class part {
    public static void main(String[] args) {
        int [] []arr=new int [3][];               //每一行都开辟列
        for(int i=0;i<arr.length;i++){
            arr[i]=new int[i+1];
            for(int j=0;j<arr[i].length;j++){
                arr[i][j]=i+1;
                System.out.println(arr[i][j]);
            }
        }
    }
}
                       还有一种方法就是每一次都把每一行的元素写进去。


                              

4、类和对象
（1）类中包含成员变量（属性，field），属性是类的一部分一般是基本数据类型，也可以是引用类型（对象、数组）；属性的访问和语法：访问修饰符+属性类型+属性名，属性不赋值会有默认的数值
（2）访问修饰符：public、protect、private。
（3）拷贝：将一个对象的数据赋值给另一个对象，直接是：类名 对象名=对象名；这样他们都指向统一对象，因此会相互影响；
（4）成员方法（成员函数）：创建样例，访问修饰符 返回值类型 函数名（参数列表）{}；
（5）成员方法的调用：1、在同一类中，可以直接相互访问
                                 2、在不同类之间调用，先在方法中创建一个要调用的方法的对象，之后便可以直接调用（在被调用对象是public时可用）。
（6）主类中的变量在被调用到对象的方法后，其数值不会受到方法的影响。但在传递的是一个引用类型的数据，如数组，原数值会受到影响，因为传递的时候，传递的是其地址，而不只是其中的数据，即不是值拷贝。
（7）可变参数：当我们在创建一个成员函数的时候，参数列表可能会出现多个数据类型相同的值，此时可以使用可变参数，语法如下，public int m_test(int...num){}；其中的“...”是不可以省略的
                        可变参数的本质是数组，因此我们在创建对象的时候也可以在参数列表中添加进数组。
                        可变参数可以与一般参数放在一起，但是应该放在最后，同时一个参数列表中只能有一个可变参数。
（8）构造方法：和c++中的构造函数是一样的。方法名和类名一致，没有返回值，自动初始化。
                       如果自己创建了一个构造方法，系统的构造方法会被覆盖掉，但是可以通过public m_T(){};重新创建一个。

5、包
（1）命名规则：只能是字母，下划线，小点，数字，开头不可以是数字，不能是关键字或者是保留字
（2）命名规范：一般小写字母+小圆点；例如，com.公司名.项目名.业务模块名。如com.sina.crm.user.
（3）java中常用的包：java.lang.*    基本包，默认导入，不需要特殊导入
                                  java.util.*  util包，系统提供的工具包，例如Scanner
                                  java.net.*     网络包，网络开发
                                  java.awt.*     java界面开发，GUI
（4）引入包的方法：第一种：引入具体的包中的某一个方向，例如，import java.util.Scanner   //只引入了util包中的Scanner类
                              第二种：引入整个包，例如，import java.util.* 
（5）project的使用：project是声明该类是在哪个包中的，应该放在类中的顶行，一个类中只能有一个包名



6、继承
（1）单继承：（1）继承的创建问题：当我们在创建一个子类对象的时候，最先创建的是辈分最高的对象依次进行创建。
                     （2）构造器的问题：如果父类只存在一个构造器，那么子类对象会先创建该构造器，当存在多个构造器的时候，则需要super（目标构造器的参数列表）；其应当放在子类构造函数的第一行，由于super和this相冲突，因此只能出现一个；在用this赋值番薯的时候应该可以。通常this是可以被输出的，而super是不可以的。
                            c++则不太相同，当子类继承父类构造函数的时候，默认会继承父类的默认构造函数，因为在创建类的时候，类中的构造函数不会像java中的构造器，在自定义构造函数后，便覆盖掉了。当然如果要制定使用哪一个构造函数。可以这样：Cat():animal(){}。由于c++可以实现多继承，因此子类可以同时继承多个父类的构造函数。
                     （3）子类对象创建的一些问题：当我们在创建子类对象后，可以使用其中的公有函数和公有成员变量。当在子类中不存在有关的调用，编译器会按照辈分依次向上寻找，如果在其中一个辈分中找到了该方法，但是不能访问，编译器会报错，此时就算比他辈分够高的类中存在可以访问的该方法依然无法访问。
                      （4）重名的问题：当我们在子类对象，但没有创建相应的父类对象的时候，想要通过子类访问父类的成员时，会遇到一个问题，如果子类与父类中同时存在的时候，由于编译器的查找优先级是子类中的由于父类中的，因此此时我们应该使用super关键字来访问父类的该成员，形如：super.n1;那么编译器就会跳过子类中的n1，直接去访问父类中的n1。同时其也遵循就近原则，根据辈分依次向前查找
                       （5）this和super的区别：当在调用方法的时候，this会先从本类中去寻找，之后依次进行寻找，而super则是跳过本类直接访问更高辈分。

（2）方法重载：当在子类中创建了一个与父类中的方法高度类似的方法，必须遵循：方法修饰名、方法名、参数列表相同，返回值类型必须是父类返回值类型的子类型，比如说父类是double，则子类返回值类型可以是int。
                       c++中由于采用动态绑定来实现重载和多态，因此运行时可以根据实际类型来确定调用哪个方法，c++重载函数的时候可以部分改变参数列表，如参数类型（类型之间可以相互转换）、参数顺序、参数个数。


7、多态
（1）使用场景：如果出现多个有类似效果的内容的时候，例如，我创建了一个管理系统的注册，注册的人可以是老师、同学、管理员。此时，多态边非常的合适。
                       本质就是一个父类有多个子类。
（2）前提：有继承关系、有父类引用指向子类、方法重载。
（3）创建子类的形式：1、在main中创建一个子类的时候，可以是Person student = new Student();（不推荐这么创建）也可以是Student student = new Student();
                   2、原理：由于Student是Person的子类，Student类的对象可以赋值Person类型的引用，这称为向上转型，本质上来说，是创建了一个子类对象，但是用父类进行引用；，应为子类继承了父类公有的所有方法和成员。
                                 3、局限性：当我们依照第一种调用的时候，当子类中出现一些子类特有的成员，创建的对象是无法使用的。不过成员方法是可以使用子类的，因为子类中的成员方法覆盖掉了父类中的成员方法。    
                   4、原理：当创建了Student student = new Student()；后，如果去调用student中的成员变量和方法的时候，其会优先调用父类中的成员变量和方法，如果没有，则会向辈分更高的类中去查找；如果找到的话，成员变量会直接输出父类中的，而方法的话，如果子类中存在着方法的重载，则会使用子类重载后的方法；这实际上是为了实现多态而做出的妥协。
                                 5、在c++中不支持这样的形式，想要实现相同的效果需要指针去实现，Student* studentPtr = new Student(); // 使用指针来创建 Student 对象
Person& studentRef = *studentPtr; // 使用引用来引用 Student 对象。
 （4）优势与不足：当我们在使用Person person=new Person（）创建的时候，就可以想创建哪个就创建哪个。但是不足的地方在于这样做不能实现子类的特有功能。
         补足：由于多态不能够事项子类的特有功能，因此可以将其再次转化为子类类型；为此我们可以添加一个判断，if（a instanceof student）{Student student=(Student)a};这里先判断a是否为Student类，如果不是，则用student去接收强转后的a。
                  在JDK14之后的版本，为了方便书写，上面的代码可以变为一行，a instanceof Student d；表达的意思是，判断是否为Student类，如果不是，直接强转变为d。


8、包和final
（1）作用：当我们在使用其它类的时候，会出现一种可能就是我调用其他包中的类的时候，可能会出现不同包有同一个类名的时候，因此，要写全包名，如果每一次调用的时候都这样会显得非常的麻烦，因此出现了import，来调用包。
（2）使用规则：1、调用本包中的类时不需要导包。2、调用java.long包中的类不需要导包。3、当同时导两个类中的同类名的时候，只能使用全类名的形式，不能导包，否则编译器不知道该使用哪个类，即使你使用全类名的方法，也依然会这样。
（3）final的使用：1、类似与c++中的const常量，被修饰的变量只能被赋值一次，被修饰的方法不能够被重写，被修饰的类不能够被被继承，里面的成员变量是可以被赋值的

9、权限修饰符
（1）private：只能在本类中进行访问
（2）不写（默认）：同一个类，同一个包中的其他类
（3）protect：同一类，同一包中的不同类，不同包下的子类
（4）public：上面三种和不同包中的不同类。

（5）类中的方法：一般情况下是公开的，除非是辅助方法，辅助一些公开的方法。

10、代码块
（1）分类：局部代码块，静态代码块、构造代码块。
（2）局部代码块：作用效果只在存在的方法之中，节约内存空间。
（3）构造代码块：将同一个类中多个构造方法中相同的内容存储进去。一般情况下，构造代码块执行的创建的实际是在构造方法之前的。
                          特点是不够灵活，当我们在其他的构造方法中不需要这个代码块中的内容时，我们是无法进行控制的，所以也会创建。
                          解决办法：出现上面的这种情况，我们可以在其中一个构造方法中写这个内容，在其他需要的构造方法中直接用this去直接调用便可以了。或者也可以将其提取为一个方法，直接调用。
（4）静态代码块：特点：随着类的加载而加载，并且只触发一次，只执行一次。调用内容的时候也只能调用static关键字修饰的
                          使用的时机：当我们在初始化一些类的数据时。


11、抽象类
（1）注意事项：抽象类中不一定有抽象方法，有抽象方法一定在抽象类中；不能创建对象。
                       抽象类的子类一定要重写抽象类中的所有方法，要么该子类也是抽象类。c++的抽象类不需要重写所有的方法（函数），只需要将其中的虚函数和纯虚函数进行重写便可以了。
（2）快捷键：当我们在子类中继承抽象类，重写的时候，可以按住ctrl+回车，选择implement，便可以导出抽象类中的所有方法，便于进行重写。
（3）抽象类中的抽象方法：虽然不能初始化，但是可以给之后的子类成员变量进行赋值
      
（4）抽象类和多态的不通点：两者都是提供统一的接口提供给对象使用，而差异主要体现在方法上，当多个人在开发一个项目的时候，有多个类中存在相似的方法和成员变量，此时可以进行提取，形成多态，重写父类中的方法，但是其中的内容要遵循一定的格式。而抽象类是，假如有一个共同的父类“吃”，我编写了猫吃鱼。另一个人编写了狗吃骨头，但是其又写了狗吃完后会拉。这样我和他重写的方法差异较大，抽象类的优势就体现出来了，其提供了一个更加宽泛的公共接口。而且这样编写的时候需要强制重写父类中的方法，使得整个项目更加直观和规范，防止有些子类没有该方法，有些子类有该方法。

12、接口（功能/规则）
（1）使用场景：假设一个父类中有多个子类，一部分子类有一个共同的方法，但是另外的一部分并不具有，这是我们就可以使用到接口，
（2）本质：实际上接口就是一种规范，是对于行为的规范
（3）语法：public interface 接口名{}；
                  接口不能够实例化，
（4）注意：一个类可以接入多个接口
                  类和接口的实现：public class Person implement swim{}；

（5）接口中成员的特点：成员变量（只能是常量，规则是不能轻易改变的）：默认修饰符为：public static final
                     构造方法：没有。
                                    成员方法：只能是抽象方法，默认是public abstract 
13、类与接口的关系
（1）类与类之间的关系：可以单继承，可以多态，但是不能多继承
（2）类与接口之间的关系：可以单实现，也可以多实现，但是多接口时，要将所有接口中的抽象类全部重写。
                                       当类中接入多个接口，如果其中有重名的抽象方法，则只需要重写一次即可，否则会报错。
（3）接口与接口的关系：可以单继承，可以多继承。接口不能继承类。
                                    如果类中调用了子接口，则需要重写所有接口的方法。
（4）JDK8后新增的功能：原因：由于在JDK8之前只能在接口中定义抽象类，这样做就意味着如果接口发生改变，连接接口的所有类都要发生变化，非常的不方便。
                                     1、功能：（1）允许接口定义默认方法，需要使用default修饰。
                                                   （2）允许定义静态方法，需要加入static修饰，不过不能通过类名或对象进行调用。
                                                   （3）允许使用私有方法，添加的原因是由于接口中有一些方法，只是辅助方法，不想被类调用。
                                                           主要的静态方法有：private 返回值类型 方法名（）{}；              //给默认方法使用
                                                                                       private static 返回值类型 方法名（）{}   //给静态方法使用
                                                          注意：由于不是抽象方法，依次不强制重写，重写的时候一定要去掉default；public可以省略不写。
                                                          当类接入多个接口，同时有多个重名的同名的默认方法，此时必须进行重写。
                                                          如果要通过类调用接口中的默认类和静态类必须要求类重写默认。
                                                          如果是静态方法，则这可以直接调用，如speak.show();表示的就是speak接口中的show静态方法

14、适配器
（1）使用场景：当我们只需要使用接口中的一个功能，但是由于接口的特点，因此必须将不想使用的方法也要重写，因此需要适配器。
（2）使用方法：创建一个新的类去连接接口，接收接口中的方法，后再将需要的方法继承给要使用到此功能的类中。
（3）注意：如果使用的类有其他父类，此时可以用适配器来继承，使用类则实现间接继承


                                     
                                         
                  



                           


 
      