---
date: 2025-07-18
aliases:
  - 黑马SpringBoot[1-10]
tags:
  - SpringBoot初识和快速入门
  - SpringBoot配置文件
  - SpringBoot整合MyBatis
  - Bean管理
---
## Spring初识
---
#### （1）简介：SpringBoot是Spring提供的快速构建Spring应用程序
#### （2）特性：起步依赖、自动配置、其它特性
		起步依赖：SpringBoot提供了启动的坐标，将所有web开发中要导入的maven坐标整合在了一起
		自动配置：在boot程序启动后，一些bean对象会自动注入到IOC容器中，不需手动声明
		其它特性：内嵌Tomcat、Jetty（无需war文件）、外部化配置、不需要XML配置（properties/yml会进行替代）


### Spring快速入门
---
#### （1）创建maven工程
#### （2）导入spring-boot-stater-web起步依赖
```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">  
  <modelVersion>4.0.0</modelVersion>  
  
  <!--继承父工程-->  
  <parent>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-parent</artifactId>  
    <version>3.5.3</version>  
  </parent>  
  
  <groupId>com.kewen.mzc</groupId>  
  <artifactId>SpringBotot-create-manual</artifactId>  
  <version>1.0-SNAPSHOT</version>  
  <packaging>jar</packaging>  
  
  <name>SpringBotot-create-manual</name>  
  <url>http://maven.apache.org</url>  
  
  <properties>    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>  
  </properties>  
  
  <dependencies>    <dependency>  
      <groupId>junit</groupId>  
      <artifactId>junit</artifactId>  
      <version>3.8.1</version>  
      <scope>test</scope>  
    </dependency>  
  
    <dependency>      <groupId>org.springframework.boot</groupId>  
      <artifactId>spring-boot-starter-web</artifactId>  
    </dependency>  
  </dependencies>  
</project>
```
#### （3）编写controller
```java
//helloController.java

@RestController  
public class helloController {  
    @RequestMapping("/hello")  
    public String hello(){  
        return "hello world";  
    }  
}
```
#### （4）启动类
```java
//SpringBootQuickStartApplication.java

//启动类  
@SpringBootApplication  
public class SpringBootQuickStartApplication {  
  
    public static void main(String[] args) {  
        SpringApplication.run(SpringBootQuickStartApplication.class, args);  
    }  
    }
```



### SpringBoot配置文件
---
### 1、配置文件的基本使用（修改端口号、虚拟目录）
#### （1）properties
```properties
//application.properties
#自定义端口号，默认为8080  
server.port=9090  
#修改虚拟目录  
server.servlet.context-path=/start
```
#### （2）yml(推荐，层次清晰，重数据)
```yml
server:  
  port: 9191  
  servlet:  
    context-path: /start2
```

### 2、yml的配置信息书写与获取
#### （1）书写
```yml
#数组的写法  
hobby:  
  - 打篮球  
  - 打豆豆  
  - 打游戏  
  
#正常写法  
user:  
  id: 1  
  name: 张三  
  password: 123456
```

#### （2）获取
![[Pasted image 20250718085706.png]]
第二种写法：此时就不用一个一个去对应了
![[Pasted image 20250718085926.png]]


### 3、SpringBoot整合MyBatis
---
#### （1）导入对应坐标（版本要对应）
```xml
<!--pom.xml-->
<dependencies>  
    <!--起步依赖-->  
    <dependency>  
        <groupId>org.springframework.boot</groupId>  
        <artifactId>spring-boot-starter-web</artifactId>  
    </dependency>  
  
    <dependency>        <groupId>org.springframework.boot</groupId>  
        <artifactId>spring-boot-starter-test</artifactId>  
        <scope>test</scope>  
    </dependency>  
  
    <!--mysql的驱动依赖-->  
    <dependency>  
        <groupId>com.mysql</groupId>  
        <artifactId>mysql-connector-j</artifactId>  
    </dependency>  
  
    <!--MyBatis的起步依赖-->  
    <dependency>  
        <groupId>org.mybatis.spring.boot</groupId>  
        <artifactId>mybatis-spring-boot-starter</artifactId>  
        <version>3.0.5</version>  
    </dependency>  
</dependencies>
```

#### （2）配置文件
```yml
spring:  
  datasource:  
    driver-class-name: com.mysql.cj.jdbc.Driver  
    url: jdbc:mysql://localhost:3306/test1  
    username: root  
    password: 2549751676
```

#### （3）Mapper层
```java
@Mapper  
public interface UserMapper {  
  
    @Select("select * from user where id=#{id}")  
    public User findById(Integer id);  
}
```
#### （4）Service层
```java
@Service  
public class UserServiceImpl implements UserService {  
  
    @Autowired  
    private UserMapper userMapper;  
  
    @Override  
    public User findById(Integer id) {  
        return userMapper.findById(id);  
    }  
}
```

#### （5）Controller层
```java
@RestController  
public class UserController {  
  
    @Autowired  
    private UserService userService;  
  
    @RequestMapping("/findById")  
    public User findById(Integer id) {  
        return userService.findById(id);  
    }  
}
```


### 4、Bean管理
---
#### （1）Bean扫描
	springBoot实现扫描的原理
			@SpringBootApplication：为组合类注解，包含了ComponentScan注解
			扫描范围：该注解所在的包及其所在的子包
#### （2）Bean注册
		如果注册的bean对象来自第三方（不是自定义的），无法使用@Componeent及其衍生声明bean
		1、使用@Bean注解
			设置配置类，并且配置类和运行方法在同一包下，导入即可生效
```java
//HelloConfig
@Configuration  
public class HelloConfig {  
//  bean对象的名字默认为方法名  
//  如果方法的内部需要使用到ioc容器中已经存在的bean对象，那么只需要在方法上声明即可，Spring会自动的注入  
    @Bean  
    public HelloService helloService(){  
        return new HelloService();  
    }  
}
```
		2、使用@Import注解
			如果配置类不和运行的方法类在同一包下或其所在包的字包下，则适合使用@Import
			实现：导入配置类
				导入ImportSelector接口实现类（当出现大量配置类）
第一种实现方法
```java
@SpringBootApplication  
//参数为数组形式，可以导入多个类  
@Import({HelloConfig.class})  
public class SpringBootRegister {  
  
    public static void main(String[] args) {  
        ConfigurableApplicationContext context = SpringApplication.run(SpringBootRegister.class, args);  
        HelloService bean = context.getBean(HelloService.class);  
        System.out.println(bean.sayHello("service"));  
    }  
}
```
第二种实现方法
	首先创建ImportSelector接口的实现类，将要注入的配置类放入
```java
//helloImportSelector.java
public class HelloImportSelector implements ImportSelector {  
    @Override  
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {  
        return new String[]{"com.kewen.mzc.controller.config.HelloConfig"};  
    }  
}
```
	然后，将ImportSelector接口的实现类导入到注解
```java
//SpringBootRegister.java

@SpringBootApplication  
//参数为数组形式，可以导入多个类  
//@Import({HelloConfig.class})  
//直接导入ImportSelector实现类的接口  
@Import(HelloImportSelector.class)  
public class SpringBootRegister {  
  
    public static void main(String[] args) {  
        ConfigurableApplicationContext context = SpringApplication.run(SpringBootRegister.class, args);  
        HelloService bean = context.getBean(HelloService.class);  
        System.out.println(bean.sayHello("service"));  
    }  
}
```

##### 注：改进版（将接口实现中的数组的数据用数据文件导入的方式获得）
```java
public class HelloImportSelector implements ImportSelector {  
    @Override  
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {  
//      读取配置文件的内容  
        List<String>imports=new ArrayList<>();  
//      导入数据文档  
        InputStream resource = HelloImportSelector.class.getClassLoader().getResourceAsStream("hello.imports");  
        try (BufferedReader br = new BufferedReader(new InputStreamReader(resource))) {  
            String line;  
            while ((line = br.readLine()) != null) {  
                imports.add(line);  
            }  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        }  
//      集合转为字符串进行输出  
        return imports.toArray(new String[0]);  
    }  
}
```

第三种实现方法 使用组合类注解
```java
//EnableHelloConfig.java

//可以在类上进行注解  
@Target(ElementType.TYPE)  
//该注解会保留在运行时阶段  
@Retention(RetentionPolicy.RUNTIME)  
//将Import注解和该注解进行组合  
@Import(HelloImportSelector.class)  
public @interface EnableHelloConfig {  
  
}
```

```java
//SpringBootRegister.java

@SpringBootApplication  
//参数为数组形式，可以导入多个类  
//@Import({HelloConfig.class})  
//直接导入ImportSelector实现类的接口  
//@Import(HelloImportSelector.class)  
@EnableHelloConfig  
public class SpringBootRegister {  
  
    public static void main(String[] args) {  
        ConfigurableApplicationContext context = SpringApplication.run(SpringBootRegister.class, args);  
        HelloService bean = context.getBean(HelloService.class);  
        System.out.println(bean.sayHello("service"));  
    }  
}
```

### （3）Bean注册条件
	作用：判断注解是否生效，如果未生效，则不进行注解
第一种：看是否参数值存在
```java
//HelloConfig.java

@Configuration  
public class HelloConfig {  
//  bean对象的名字默认为方法名  
  
//  如果配置文件中配置了对应的信息，则进行注入，否则不注入  
    @ConditionalOnProperty(prefix = "Visited",name = {"name"})  
    @Bean  
    public HelloService helloService(@Value("${Visited.name}") String name){  
        HelloService helloService = new HelloService();  
        helloService.setName(name);  
  
        return helloService;  
    }  
}
```

第二种：看ioc容器中是否存在参数中的bean对象，没有则不进行注入
	如果判断的是当前要注入的类也是可以的，不认为是没有注入
```java
@Configuration  
public class HelloConfig {  
//  bean对象的名字默认为方法名  
  
//  如果ioc容器中有HelloService对象则注入，否则不注入  
    @ConditionalOnMissingBean(HelloService.class)  
    @Bean  
    public HelloService helloService(){  
        return new HelloService();  
    }  
}
```
第三种：如果存在指定的类，则进行注入，否则不进行
```java
//HelloConfig.java

@Configuration  
public class HelloConfig {  
//  bean对象的名字默认为方法名  
  
    @Bean  
//  如果存在该类，则进行注入，否则不进行注入  
    @ConditionalOnClass(name = "com.kewen.mzc.controller.HelloService")  
    public HelloService helloService(){  
        return new HelloService();  
    }  
}
```

