1、class与struct的区别：（1）基本上没有区别，但有一些小小的区别
                                        （2）首先是struct内的默认区域是public，class的默认区域是private
                       （3）class更加规范和严谨，但是struct并不是一无是处，其是为了保持与c语言的后兼容性
 2、class与struct之间的关联：两者是可以相互继承的，不过最好不要这样，因为两者还是有一些区别的，在某些编译器中，其会发出警告，不过依然可以继续运行
                                               如果只是想要表示一些数据的话，用struct感觉会好一些，如果是要包含大量的功能，用class应该会更好一些
3、类的成员量的一些使用方法：（1）如果成员量在public区域内，则甚至可以创建对象中的默认参数中使用另一个对象的成员量（可以不是同一个类），静态的成员量也行
4、静态在class或struct外部：static是可以在外部独立创建的，即全局静态变量，其可以在全局内被调用。
5、关于全局变量的重定义问题：（1）出现这种问题的前提是两者在同一个全局域中，例如，我的源文件并没有引入头文件，则头文件中与其重名的全局变量并不会出现重定义的问题，因为其根本就没引入头文件中的这个全局变量。排除这种情况后，我们遇到重定义的话，可以通过extern来解决，例如，在头文件中：int num1=15；在源文件中：extern int num1；从而解决了这个问题。
                                              （2）不过当这个为全局静态，用extern就失去了作用，因为在使用static后，其相当于变成了这个文件私有的，并不能通过extern来建立连接。当时这时由于变成了该文件的私有，所以在其他文件中也是不可见的，所以直接就不存在重定义的问题了。
                           （3）尽量避免使用全局变量，其导致了命名空间的污染，容易导致意外的修改和依赖关系，导致产生严重的问题
6、静态在class或struct内部：静态是无法再类内进行定义的，因此如果只是像这样 static int x；这并不是一个static的定义，而只是在类中声明有这个static存在，还需要在类外进行int number1::x=15；这样才对其进行了定义。如果是static函数，其只能调用全局变量和static量，因为其实际上并不属于类的成员，而是属于全局，因此其无法识别类中的成员，从而无法调用类的成员量，这时如果想要调用成员量，可以在参数列表中进行类的引用，这样便可以进行调用，注意这时在static内部使用时，一定要在其前端附上对象名和“::”
7、局部静态：可以使得一些局部的变量，例如函数中的变量，延长其生命的周期，因为一般在进行完函数调用后，函数中的变量会自动销毁。例如，
                     void num1（）{ static int x=0；x++;cout<<x<<emdl;}  int main（）{num1();num1();num1()},输出的结果会是1,2,3.而不是1、1、1。
8、对象生存周期：栈可以认为是一种数据结构，可以在上面堆叠一些东西，在这上面的变量会在作用域中完成使命后，被释放掉。在main函数中创建类的对象调用的实际上是该类的默认构造函数。如果是指针函数，假设没有使用new delete来控制释放，会导致在函数结束后，返回值指针指向无效的内存空间，产生悬指针。因此想在函数指针外调用内部的数据，最好将其分配到堆区中
9、作用指针：（1）它是一个类，它相当于是一个指针的包装器，在构造函数时分配指针，在析构时删除指针，从而实现自动化的new和delete。
                     （2）其基本的格式如下：
#include<iostream>
using namespace std;

class data{
private:
  int*m_num1;
public:
  data(int*num1):m_num1(num1){}
  
  ~data(){
   delete m_num1;
}
}