1、判断变量是否为相应类型，例如判断变量a是否为整数，if（a==int（））
2、取一个数的不同位的方法：例如153，取其个位数：先用10去取模；
                                                         取其十位数：先除以10，再取模，
                                                         取百位数：除以100。
3、不同的数据类型所占的内存大小：整型：int 4；short 1；long 4；long long 8
                              实型：double 8；float 4
                              字符型：char 1
                              字符串型：40
4、数组、函数、指针的综合运用：例题，对于一个数组进行升序排列，数组为int arr[4]={2,4,1,5}
   解法：
#include<iostream>
#include"1.h"
using namespace std;

int app(int*arr, int len) {                                 //注意这里的参数列表的int*arr可以改为int arr[]，这两者意思有所不同第一种是告诉编译器有这么一个地址
	for (int i = 0; i < len-1; i++) {                   //使得编译器可在之后的编译过程中进行调用，第二种则是直接告诉编译器这里要输出的是一个数组，如果在调用
 		for (int j = 0; j < len-i-1; j++) {         //时使用其它类型编译器会报错实参与形参不兼容。
			if (arr[j] > arr[j+1]) {
				int temp = arr[j];
				arr[j] = arr[j+1];
				arr[j+1] = temp;
			}
		}
	}
	return 0;
}
int main() {
	int blue[4] = { 2,4,1,5 };
	int o = sizeof(blue) / sizeof(blue[0]);
	app(blue, o);
	for (int j = 0; j < 4; j++) {
		cout << blue[j] << endl;
	}
}
5、在创建函数的时候可以引用其它函数。
6、在Switch选择结构中，在case:中输入内容过长时或要在此中初始化变量则需要在case：后加{}将内容输入在花括号中。

一、面相对象的基本概念
（一）对象：
        1、任何对象都包含属性和行为这两个要素。
        2、对象是面相对象的基本组成单位，每个对象都是由数据与函数组成
（二）类：
        1、其是对象的抽象，对象是类的实例
（三）面相对象设计的四大特点：抽象性，封装性，继承性，多态性
（四）函数的本体告诉编译器检测实参的个数、类型、顺序。
（五）类中的成员可以分为：静态成员，动态成员


二、头文件与类的声明
（一）创建对象可以大体分为两类：复数与字符串。1、复数类：要有实部与虚部，同时还要设计其中的加减乘除，共轭，正弦等函数。\n
                                          2、字符串型：设计相应的拷贝、输出、附加、插入函数。\n
（二）复数类：1、没有指针：编写c++程序大体可以分为三大部分：头文件、程序主题、标准库（不一定会用上）\n
                      2、在编写代码主体的时候要先建立防卫式声明，主题如下：#ifndef _COMPLEX_  //这里的_COMPLEX_是指自创的一个头文件   \n      
                                                             #define _COMPLEX_        \n               
                                                                                                          
                                                             头文件内容                                 \n
                                                             #endif                       \n
               要注意的是其保护的是特定的头文件，尤其是自己编写的头文件，标准库的头文件，编译器本身已经采取了相应的措施去防止标准库中的头文件被多次定义。一般每个自定义的头文件都应有唯一的防卫式声明宏，去防止与其他头文件冲突
                      3、函数的重复定义：（1）确保该头文件在整个工程中只被包含一次。 （2）不要在另一个头文件中包含该头文件，因为另一个头文件很可能被其他的源文件包含，从而造成重复包含，重复定义。 （3）只在一个源文件或头文件中包含该头文件。
                      4、头文件（复数）的布局：#ifndef _COMPLEX_                //前置声明
                                    #define _COMPLEX_
                                    
                                    include<cmath>
                                    class ostream;
                                    class complex;
                                      
                                    complex&
                                       __doapl(complex*ths,constcomplex&r);
                                    template<typename T>     //模版，当不能确定数据的具体类型是可以调用
                                    class complex       //类声明（类的头部）
                                    {
                                    public:             //类的主题 
                                          complex(double r=0,double i=0)                //构造函数，即创建一个对象，可以没有返回值
                                              : re(r),im(i)                             //初值列，初始列。
                                          {}                                           
                                          complex& operator +=(const complex&);        //不是所有的函数都会在类的主体上进行定义，有一些会在类之外进行定义，如这一行就只是在这里进行声明，并没有在这里定义
                                          double real () const{return re;}             //这两行函数在类中直接进行定义，与上上行的{}构成了一个内联函数
                                          double imag () const{return im;}
                                    private:
                                      T re,im;         //re为实部，im为虚部，这里为定义一个实部和虚部的值，具体的数据类型待定。
                                      
                                      friend complex&__doapl(complex*,const complex&);
                                    };
                           
                                    complex::function ...     //类的定义 \
                                                              #endif
               5、模版：当创建一个变量时，不能确定该变量时什么类型时，可以用模版，使在具体的使用是再确定数据类型，使用时应先输入template<typename T>     //这里的T可以为其它名字，用法是在创建的变量前加T，即可使其在输出时再确定类型                        
                                    模版的用法：{complex<double>c1(2.5,3.14,4.1,5.17);
                                                complex<int>c2(1,3,5,7);}
               6、内联函数：（1）通常在头文件中定义，以便其在多个源文件中进行展开，使得内联函数的定义可以在多个编译单元中可见。\n
                           （2）作用：通常用inline去调用内联函数，内联函数中的函数体会直接插入到调用到的地方（同时内联函数中可以包含其它函数），而不会生成一个独立的函数，减少函数调用时的开销。\n
                           （3）局限性：是否内联由编译器决定，即使使用了inline去建议编译器将函数内联，但是编译器会结合函数的复杂程度和性能优化来决定是否内联，因此内联的函数多是简单的且使用频繁的函数。\n
                           （4）广泛性：标准库中内联也有广泛的应用，如标准库中的容器类成员，通常为内联函数。
                           （5）用法：inline 数据类型 函数名称（参数列表）{函数体}

                           7、访问级别：在一个本体之中可以分为几大板块，用public和private分割开来，其中public是对于外界公开的，private是私人才能看的到，一般为数据，因为我们希望数据是封装的，
                                 例如：在对于复数这个头文件的调用时，正确的是：complex d1（1,2）          错误的是：complex d1(1,2)
                                                                                                         cout<<d1.real();                cout<<d1.re;
                                                             cout<<d1.imag();                cout<<d1.im;
                8、构造函数：可以没有返回值，可以在主题部分没有内容，要有初值列，设初值列的原因是在创建一个变量的时候会经历两个阶段，一个是初值化阶段，一个是赋值化阶段，如果你不设置初始化，而是在{}内去写，相当于你放弃了初始化，这样会增加时间成本，降低效率。构造函数是不能被直接调用的，只能创建对象，自然构造函数就会被调用起来。
                9、常量成员函数：当我不想对于创建的某一个函数在调用时进行修改，则可以用const去使其常量化，在函数体本身如 double imag () const{return im;}，如果没有加const，而使用者在调用这个函数时却使用了const，例如，const double（1.2,2.4），这时系统会报错。                                                                         
               10、传引用：complex& operator +=(const complex&），这里的complex&就是传引用，好处是可以减少内存空间的占用与运行时间，注意传引用是可以影响实参的，如果不想更改实参要在complex&前加上const
               11、返回值传递：尽量也是用引用传递，如complex& operator +=(const complex&)，好处同上
               12、友元：可以使得某些函数可以调用被封装好的函数，并进行修改，例如， friend complex&__doapl(complex*,const complex&);这时一个友元的声明，即声明__doapl的函数时complex函数的友元，此时__doapl可以自由的取得private中的成员。这样做有一个问题就是当友元太多时，会导致被封装的函数的不到很好的保护，如果不是友元，在拿构造体的封装中的数，则可能需要调用某一个函数，去拿，这样可能会影响速度。
                        注意的一点是当在同一个class（类）中的各个部分可以理解为互为友元，可以直接调用封装内的东西，不过友元的概念告诉我们，友元应当满足是非成员函数，且两者满足友好关系                                   
               13、当在类外调用类内的函数，因为成员函数都在类的作用域内，所以想要调用成员函数要使用成员调用运算符“.” 例如：student s;s.num1；即创建一个关于student的类和对象，再调用类和对象s的num1成员函数。这里调用的必须是在公共域内的函数。                                                             
               14、注意有些成员函数是不在类的领域内的，这样的函数要现在类中声明，再在外面创建函数时加上“::”，例如：class student{void input（）}；void student：：input（）{}。      基本格式为   函数类型 类名::函数名（参数值）{}
               15、类的继承：类是存在继承关系的，被继承的称为父类或基类，继承的称为子类或派生类，派生类继承了基类的成员，同时还可以具备自己的成员，或者对基类的成员进行覆盖，注意派生类不可以访问基类的私有区域，相关的语法是class Myclass:public name{}，表达的意思就是Myclass类继承了name类的公共区域。
               16、类的嵌套：类中是可以存在类的，在类的内部的称为内部类，其可以访问内部类的私有成员。
               17、this指针：其是一种隐式指针，通常用于成员函数内部要调用成员变量和成员函数，例如：

 class MyClass {
public:
    void setX(int x) {
        this->x = x; // 使用this指针访问成员变量x
    }

    int getX() {
        return x; // 直接访问成员变量x
    }

private:
    int x;
};

int main() {
    MyClass obj;
    obj.setX(42);
    std::cout << "x = " << obj.getX() << std::endl;
    return 0;
}
四、使用构造函数初始化对象
     （一）构造体函数创立：1、需要满足的条件时：构造函数的函数名必须与类的名称相同；不需要参数类型（不需要返回值）；如果用户没有定义构造体函数，系统会自动生成一个，且只能生成一次。
                                        2、构造体函数一般一个类中只有一个，如果出现多个可以用重载的方式进行调用，但是用该类建立对象是只能选择一个构造函数进行调用。
                                        3、类的构造函数的语法：void 构造体名（参数）：参数{}注意着里的初始化
                                        4、默认构造体函数：（1）即在创立这个构造函数时没有形参，或者形参是已有的默认参数时，称为默认形参。
                                                                   （2）默认构造函数对于初始化对象的成员变量具有初始化值的作用，以防止访问未初始化的内存。
                                                                   （3）类中只能有一个默认构造体。  
                                        5、转换构造函数：（1）通常是件单个参数的构造体函数，这个参数与当前的类型不同，当需要一个对象从一中类型转换为另一种类型时，编译器会自动使用适当的转换构造函数。例如：
#include <iostream>

class Celsius {
public:
    Celsius(double celsius) : temperature(celsius) {}
    
    double getTemperature() {
        return temperature;
    }

private:
    double temperature;
};

class Fahrenheit {
public:
    // 转换构造函数，将Celsius对象转换为Fahrenheit
    Fahrenheit(const Celsius& celsius) {
        temperature = (celsius.getTemperature() * 9.0/5.0) + 32.0;
    }

    double getTemperature() {
        return temperature;
    }

private:
    double temperature;
};

int main() {
    Celsius celsius(25.0);
    Fahrenheit fahrenheit = celsius; // 调用转换构造函数将Celsius对象转换为Fahrenheit

    std::cout << "Celsius: " << celsius.getTemperature() << "°C" << std::endl;
    std::cout << "Fahrenheit: " << fahrenheit.getTemperature() << "°F" << std::endl;

    return 0;
}
 （2）一般转换构造体函数用在：一个类的对象转换为另一个类的对象；从一个数据类型转换到另一个数据类型；从自定义类型转换为标准类型
                       5、析构函数：（1）是一个较为特殊的存在，其主要工作是在对象的声明周期结束后，对于对象的数据进行清理，以防止内存的泄漏。
                                                            （2）语法：~类名（）{要进行释放的方式}    当然也可以不加花括号。
                                                             （3）适用的情况：对于用new创建的动态运算符；全局对象生命结束时。
                       6、接口与实现的分离：（1）当我们在上面的编写中，由于类和输出都放在同一个程序中，用户在使用时可以查看类的实现，这在做项目尤其是大项目中是不允许
                                                                        （2）接口与分离实现的过程很简单，只要将类的定义放在头文件中，将需要编写的成员函数放在一个源文件中，在源文件中要加上#include“头文件名”，从而实现连接的。
                        7、空类：当我们在创建一个类时，如果里边什么都没有输入，则编译器会自动生成一段，其中包含默认构造函数，拷贝构造函数，析构函数，赋值运算符，取地址运算符，const取地址运算符。
                                         8、this指针：（1）其是一个隐藏的指针，不能直接参参数中写出，但可以在函数中进行使用
                                                              （2）作用：首先是存在参数与成员同名的情况，可以用this指针指向成员，明确到底要调用谁。例如：
                                                                                class MyClass {
public:
    void setX(int x) {
        this->x = x; // 使用 this 指针来区分成员变量 x 和参数 x
    }
private:
    int x;
};
                                                                                然后是使用this指针可以让成员函数可以调用其它成员函数或成员量，不过也可以直接调用，之所以这样做是因为可以消除歧义，以及明确其是从哪里调用来的。
                                                                                最后也是比较重要的是，使用this指针，可以使得返回对象本身，使得链式调用，例如：
class MyClass {
public:
    MyClass& setA(int a) {
        this->a = a;
        return *this;
    }

    MyClass& setB(int b) {                     //这里的MyClass&是声明返回值是一个引用，使得可以返回其本身，使得形成链式调用，注意使用应用返回时不要返回在函数中存在          
        this->b = b;                             的变量
        return *this;
    }

    MyClass& setC(int c) {
        this->c = c;
        return *this;
    }

    void display() {
        cout << "A: " << a << ", B: " << b << ", C: " << c << endl;
    }

private:
    int a, b, c;
};

int main() {
    MyClass obj;
    obj.setA(1).setB(2).setC(3).display(); // 链式调用
    return 0;
}

五、类的深入剖析
     （一）1、类的作用域和类成员的访问：隐藏机制：当在成员函数中定义了和成员量名一样的变量，则成员量在该函数的作用域内会被该定义的变量覆盖，如果还要是用的话可以使用this指针去指向成员量，从而使得成员量在该成员函数中不被隐藏；当然也可以在被调用的成员量前加类名作用域运算符“::”                 
           2、对类的对象进行赋值和复制：（1）通过构造函数进行初始化变量，不只是成员变量，其分为两种形式：首先是name():data(15){}即对许data初始化为15，然后是name（）{data=15}。第一种相较于第二种，有更好的运行效率和稳定性，有利于维护和程序的稳定性。
                                                                （2）对象是可以赋值的，将一个对象的成员变量赋值到另一个对象中，这种操作通常是相同类的对象之间进行的操作，当然这不是绝对的，如果一个类是另一个类的派生类，也是两者之间的对象也是允许进行赋值的操作。
                                                                （3）函数指针：可以使用指针指向函数，具体的语法是：返回值类型 （*指针名）（要指向函数类型参数列表中的参数的数据类型）                                                                                                                                 
                                     （4）使用函数指针实现对象之间成员函数的调用：例如：
#include <iostream>

class MyClass {
public:
    MyClass(int value) : data(value) {}

    // 假设你要共享的成员函数的原型是 void func()
    void func() {
        std::cout << "Data: " << data << std::endl;
    }

    // 创建一个函数指针，指向成员函数 func
    void (MyClass::*funcPtr)() = &MyClass::func;                     //注意这里不能函数指针指向构造函数或析构函数，因为他们自身的地址是不能够被提取的。
                                                                     //注意这里在类的内部创建了一个函数指针并将其指向成员函数，必须在创建函数指针的时候在其指针名 
private:                                                             //加上类名调用运算符，Myclass::，才能事项操作
    int data;
};

int main() {
    MyClass obj1(42);
    MyClass obj2(24);

                                                                   // 使用函数指针来赋值 obj2 的 func 函数指向 obj1 的 func 函数
    obj2.funcPtr = obj1.funcPtr;

    // 现在 obj2 和 obj1 共享了相同的成员函数
    obj1.func();
    obj2.func();

    return 0;
}
                                          （5）对象的复制：构造函数拷贝：在创建类的时候对于构造函数中进行如下操作：Myclass（const Myclass& other）这里的Myclass是类名，other是要拷贝的函数名，可以是不同的名称，但一般为other。注意构造函数拷贝的只是被拷贝的对象的成员变量。之后在主函数中是：Myclass s1； Myclass s2=s1;Myclass s3(s1);这两种复制的方法都是可以的
                                                                                                   好处：实现数据的隔离，安全性，防止恶意篡改数据，只要原对象不被更改，在大型数据结构时最好使用对象指针，防止不必要的内存占用。
                                                                                                  与对象赋值的区别：赋值主要是对已存在的函数进行修改，而复制时利用已有的对象创建一个新的对象
                                                                                                 赋值操作符重载函数：标注语法：
 MyClass& operator=(const MyClass& other) {
        if (this == &other) {
            return *this; // 自赋值，直接返回当前对象
        }
        data = other.data;                                       //这里是为了确保拷贝的对象正确的复制了该成员变量。
        return *this; // 返回当前对象的引用，以支持链式赋值
    }
                                           （6）从上面的代码发现一个现象：当类中的成员量被初始化值，但在主函数中被重新赋值，则以被赋值的为准。







class Myclass{
public:
    int a;
    Myclass&(const Myclass& other){
           if(this==&other){
       return*this;}
                                         （7）const对象与const成员函数：创建一个const对象的语法：在主函数中创建一个对象是在前面加上const
                                                                      创建一个const成员函数的语法：在类中创建成员函数中，void s1() const{}
                                                                      const对象中的成员量可以被调用，但是不能被修改（重新赋值的操作），非const成员函数不能被调用，const成员函数可以被调用，注意在创建一个const成员函数中编译器会强制不允许在其内部对于成员量进行修改。 
                                         （8）mutable数据成员：在类中存在着这一数据类型，其可以不受const对象和const成员函数的影响，任意进行调用和修改。以便于对于const对象内部状态和某些特殊行为，即使是在const成员函数中也可以对其进行修改
                    3、在创建类中的一些注意事项：类的定义和实现放在不同的源文件中，最好每一个成员函数的定义放在一个独立的源文件中，防止在多个源文件中包含相同的类定义。
                                               不要将成员函数的定义放在和主函数同一个源文件加中，提高运行效率
（二）类作为函数的参数
1、种类：void s1(Myclass a);void s2(const Myclass b);void s3(Myclass*c);void s4(const Myclass*d);void s5(Myclass&e);void s6(const Myclass*f)
2、作用：一般用于传递对象的数据，以便在函数中对这些数据进行操作。 
3、类作为函数的参数，函数要创建在主函数的外边，不能再主函数中创建对象后，然后再用创建的函数进行创建，当然函数也应该创建在主函数的外边。
（三）动态创建于删除对象
1、在创建了一个类后，在主函数中，使用指针创建一个动态指针，具体的语法是：int main(){ Data*s1=new Data("woshishei")};这样就创建了一个动态对象。
   另一种是int main(){Data*s2=new Data[3];s2[0].name("woshizhei");};这种方法的理解为创建了一个数组指针s2，[3]表示有三个对象元素，类似于数组，而s2[0].name("woshizhei"）；表示的是对于s2的数组指针中的第一个对象元素进行定义，以此来进行区别。
注意当在成员函数中出现参数列表中参数为同类对象的时候（不管是引用还是值传递），其在调用过程中，函数成员的调用以指针指向的对象的构造函数的初始化对象为准
2、运算符的优先级问题：括号具有最高的优先级，紧随其后的是递增/递减运算符。
乘法和除法运算符具有比加法和减法更高的优先级。
关系运算符（如<、>、<=、>=）通常具有比等号运算符（==）更高的优先级。
逻辑运算符（如&&和||）具有较低的优先级。
赋值运算符（=）通常具有较低的优先级。
条件运算符（?:）的优先级较低。

3、protect和private区域的不同：protect区域的成员可以被派生类所调用，而private区域的则不可以，因此，protect区域多用于继承的方面。
4、在创建函数中的返回值类型设置为类的引用的时候，返回值可以用this指向对象，但是要在this前面加上*，因为this本事也是一个指针。
（四）static成员（分为成员函数和成员量，其是类中的静态量）
1、使用的背景：（1）每个类中的非静态成员，其都会拷贝一个副本，当每创建一个对象的时候，都会生成一个一样的副本，这样会占有很多的空间，同时还有另一个问题，当我们要在类往函数中，使用引用去尝试输出类中的成员量，结果不会实现，因为其在引用时会首先引用this指针，这时便可以使用友元来解决这个问题。
                       （2）解决的原理，由于static成员属于静态成员，因此其函数不会生成this指针，其static成员量可以被全局使用，减少了内存的占用。
2、static的性质：static成员是可以在类外进行定义的，，前提是static成员必须在public区域内，在另外两个区域中与其他成员的规则相同,注意static成员访问是可以直接进行访问，也推荐这样去访问。
3、语法：类外进行定义时：现在类的公共区域中进行声明如：static int num1;之后在类外进行定义时，int static num1=15;
4、注意点：在const成员函数中，其没有this指针，以此只能调用函数本身所有的数据。
（五）友元
1、意义：面对一个复杂的问题需要用多个类去描述时，没有友元，则只能用指针去进行调用，占用内存，且降低效率。因此这时友元便是一个很好的选择。
2、性质：（1）友元不受访问的限制，因此其可以在类中的任何区域。
              （2）友元的关系是不对称的，即类a中声明类b是其友元函数，b可以调用a中的任何数据，但是不代表a就是b的友元，两者不是相互对等的。
              （3）友元关系是不传递的，即类a时类b的友元函数，类c是类a的友元，不代表c是b的友元
3、语法：友元类  friend class 类名；友元函数：friend 函数类型 函数名（参数）{}
4、注意事项：（1）友元函数中，在main函数中对于已经定义好的友元函数，只需要输出函数名即可，参数中也只需要使用类名即可。
                     （2）在使用被友元类的类中成员的时候要在前面加上：类名.成员。
（五）组合
1、定义：一个类包含另一个类的实例作为成员，通常被组合的类是组合类的一部分，而不是和组合类存在继承关系。
2、使用场合：当一个类中应该“有什么”的时候，可以使用组合，例如一个人的脸是由眼睛、嘴巴、鼻子等组成，而他们具体是什么样的，可以构造被组合类，来进行详细的描述
3、语法：在组合类的命名中将原来的数据类型改为类名：如Data m_Data,代表着在这个组合类中包含一个Data类，而在组合类中它的代号为m_Data.

（六）类的继承、组合、嵌套的区别
1、组合： （1）组合是指一个类包含另一个类的实例作为成员。被包含的类通常是组合类的一部分，但不是继承关系。
         （2）使用场合：当一个类中应该“有什么”的时候，可以使用组合，例如一个人的脸是由眼睛、嘴巴、鼻子等组成，而他们具体是什么样的，可以构造被组合类，来进行详细的描述
                （3）组合的优势： 降低耦合性，支持模块化设计，有助于代码的灵活性和可维护性。
                （4）组合的劣势： 可能需要编写更多的委托代码，需要管理包含对象的生命周期。
2、继承：（1）定义： 通过继承，一个类可以继承另一个类的属性和行为。子类（派生类）可以拥有父类（基类）的成员，并且可以添加自己的新成员或修改继承的成员。
         （2）使用场合： 当一个类表示一种 "是什么" 的关系时，通常使用继承。例如，动物类可以是一个基类，而狗类和猫类可以是继承自动物类的派生类。
                 （3）继承的优势： 提高代码的重用性，创建层次结构以表示类之间的关系，可以实现多态，有助于代码的扩展性和维护性。
                  （4）继承的劣势： 可能导致紧密的耦合，继承链过深可能使设计复杂化，子类对父类的依赖性较高。
3、嵌套：（1）定义： 一个类嵌套在另一个类中，形成所谓的内部类。内部类可以访问外部类的成员，但外部类不能直接访问内部类的成员。
               （2）使用场合： 嵌套类通常用于表示一种包含关系，其中内部类是外部类的一部分。例如，一个汽车类可能包含一个引擎类作为嵌套类，因为引擎是汽车的一部分。
               （3）嵌套的优势： 可以将相关的类组织在一起，隐藏实现的细节，有助于模块化设计。
               （4）嵌套的劣势： 内部类的访问限制可能增加复杂性，某些情况下可能使代码变得难以理解。
4、使用的优先程度：优先使用组合。
六、类的继承
（一）1、（1）基类和派生类：在c++中的继承机制的语法中，被继承的类称为基类，继承的类称为派生类。
              （2）派生类对于从基类中继承来的数据进行操作的时候，不会影响基类中的数据
        （3）继承的分类：直接继承：派生类直接从基类进行继承的
                                        间接继承：派生类继承基类的数据是通过多次继承得来的。
                                        单继承：指派生类是由单个基类继承过来的，
                                        多继承：指派生类的数据是有过过个基类进行继承的
       （4）继承的语法：在要进行继承的类的后面加上要继承的类的区域，例如：class collegestudent:public student{},这里表示的就是collegestudent类继承student的public区域。即class 派生类名：类派生表 
       （5）注意项：当派生类类派生表中声明的是继承protect区域，则基类中public区域也会在派生类中被分配到protect区域，private区域不影响
                                 当派生了类派生表中声明的是继承private区域，则基类中的所有区域都会被分配到派生类的private区域
     2、using的使用：（1）衍生用法：当我们在派生类的过程中如果没有声明到底要继承哪一个区域，这时编译器会将其全部放在派生类的private区域中，这时如果我们想将其中的某些区域调用到其它区域，则需要谁用using，但其主要作用并不是在于此。
                    （2）正常用法：当我们想调用类派生表中没有声明的区域中的数据时，在没有使用友元等其他方式的情况下，我们可以使用using来直接进行调用，这样更加方便，但是这样可能会影响代码的封装性。	
                    （3）语法：using student::privateData。这里就是使用using调用student类中的privateData数据，如果其在private或protect区域，被using到public区域，则其在派生类作用域中是public区域，在类外，其依旧是private或protect区域中的数据。
（二）派生类对象的构成
1、static的继承：static数据成员由于不属于类的实例对象，因此也可以被继承到派生类中。
2、特点：继承里基类的成员量和成员函数，但其不会在派生类中直接有显示，即有明确的定义，而组合会出现有基类名称的情况
（三）派生类的访问
1、不同的访问类型：（1）基类中的成员函数访问派生类的成员量是不可以的，因为基类并没有继承或者友元派生类，因此并不可行。
                              （2）派生类的成员函数访问基类中的成员和派生类的对象访问基类中的成员
2、protect成员：（1）介于public与private区域之间的一个权限等级，其不可以被对象或类外进行调用，但可以被友元和成员函数的调用，与private的区别在于其数据可以被继承类直接进行访问。
                       （2）注意事项：在派生类的成员函数中，对于基类protect区域内的数据，直接进行调用，尤其是在使用组合的时候，用组合进行访问protect区域中的数据是无法进行访问的。还有一点就是，派生类的对象是不能够调用继承基类中的protect和private区域中的成员函数和成员量。
3、派生类的构造函数：派生类的构造函数不必直接调用基类的构造函数，编译器会自动调用默认的构造函数。如果基类没有默认的构造函数或时有多个构造函数，则就需要显示基类的构造函数。基类的构造函数优先级更高。
（四）多继承和虚基类
1、在派生类中声明多个基类，称为多继承。
2、多继承中派生类构造函数：可以同时使用多个基类的构造函数，且按照声明的顺序来确定优先级。
3、二义性：多基类必然会带来不同基类存在同名的成员，这种情况下，编译器不知道作何选择，因此产生二义性的问题。
4、解决多义性的方法：当产生二义性的基类来自于不同的上基类（即这两个基类的父类并不相同，或者其就是元基类），可以通过作用域运算符“::”解决
                                 当两个基类拥有相同的基类，称为菱形继承，这时两个基类的默认构造函数中会有一个相同的构造函数，这时编译器会无法识别，因此引入了“虚基类”的概念
5、虚基类：声明一个类在整个继承体系中只有一个实例，即只有一份构造函数，这样就很好的解决了菱形继承的问题。

（五）多态性
1、特性：（1）方法重写，即父类与子类具有相同的函数名的方法
               （2）向上类型转化，即用父类指针指向子类对象的时候，加入调用的是虚函数，会自动暂时将该指针转化为子类类型的指针。
2、即使没有虚函数，也是可以重写方法的；假设，创建父类与子类各一个，在两个类中，分别创建相同的函数，在main函数中分别创建对象，然后输出，可以发现也是可以进行重写的
3、子类对象也是可以调用父类的同名方法，即在创建子类对象后，在调用重名的函数的时候，在函数名前，“.”后加类名和作用域，则会调用函数父类的同名函数
4、没有虚类的基类指针，还是基类指针，不会类型转换。例如 people s1=new man();s1->num1();其最后输出的是父类的num1函数，因为其是父类的指针，因此会调用父类的函数，即使其存在子类的内存地址，也就是说其没有改变指向。
5、虚函数：在父类与子类的同命函数前加上 virtual，便可实现4中无法实现的效果，即向上类型转化。而且可以认为这是一种局部性的特性，只针对同名的函数，对于其它成员函数没有效果
          原理是在使用virtual的子类同名函数，覆盖了父类的同名函数，实现了在父类指针中，调用子类的函数，由于是覆盖，并没有进行替代，因此称为虚函数。这种覆盖的方式是长期的，只要继承和覆盖关系正确，如果在派生类中修改了虚数的参数，此时该函数不在被认为是覆盖，此时覆盖失效
6、虚指针和虚表：在上面所说的向上类型转换，并不是真的类型转换，而是通过虚指针和虚表实现的。虚表是存储虚函数的，虚表不会占用内促空间，但是虚指针会占用内存空间。
7、虚指针实现多态性的方法：虚指针式一个二级指针，其被一个指针所指向，其又指向一个对象。假设指向虚指针的指针称为p，即对象指针，虚指针会根据p的要求指向对应的虚函数。
8、只能用父类的指针指向子类，而不能用子类的指针指向父类。
（六）运算符重载
1、条件：（1）只能对已经存在的运算符进行重载，即只能重载编译器已经储存好的运算符，
        （2）一个运算符不能重载为另一个运算符，因为每个运算符都有着自己的语法和规则
        （3）只能在类中的成员函数或是全局函数中进行运算符重载
2、语法：函数返回值类型 operator运算符（参数列表）{}。例如 MyClass operator+(const Myclass&op1,const MyClass&op2)const{return(op1.num1+op2.num1)}即参数输入了两个MyClass类的引用，并返回两个操作数相加的结果，返回给一个新的对象作为其 num1的数值。在main函数中，可以输出Myclass s3=S1+S2,即这样做实现了a+b的实现，其中的const在对于重载不修改调用对象状态的运算符（特别是加减），有利于程序的优化



运算符重载
运算符重载的意义：当两个自定义的变量需要进行运算的时候，编译器无法进行理解，所以引入了运算符重载。
1、四则运算：语法：（1）先创建一个类在类中创建一个重载函数，在该函数的参数中创建一个引用对象，在函数中创建一个临时对象，将临时对象中的变量进行定义，最后返回该临时对象。代码如下：
#include<iostream>
#include<string>
using namespace std;

class person {
public:
	person operator+(person& p) {
		person temp;
		temp.m_a = this->m_a + p.m_a;
		temp.m_b = this->m_b + p.m_b;
		return temp;
	}

	int m_a;
	int m_b;
};

                        （2）在全局中创建一个函数重载。先创建一个类，在全局中创建一个重载函数，在函数参数列表中，引用两个对象，在函数中创建一个临时对象，对于临时对象中的变量进行定义，最后返回临时对象。	代码如下：
#include<iostream>
#include<string>
using namespace std;

class people {
public:
	int m_num1;
	int m_num2;
};

people operator+(people& p1, people& p2) {
	people temp;
	temp.m_num1 = p1.m_num1 + p2.m_num1;
	temp.m_num2 = p1.m_num2 + p2.m_num2;
	return temp;
}


int main() {
	people sum1;
	sum1.m_num1 = 15;
	sum1.m_num2 = 10;
	people sum2;
	sum2.m_num1 = 25;
	sum2.m_num2 = 20;
	people sum3 = sum1 + sum2;
	cout << sum3.m_num1 << endl;
}
2、注意：不仅是对象之间可以进行相加，也可以实现兑现于变量之间的重载，只要对于符号进行不同的重载，便可以是先不同的效果，有点类似于函数重载。
3、左移运算符重载：（1）应用的情况，在进行输出对象的时候会发现无法直接输出对象，而是只能进行指明到底是哪个成员变量，因此便引出了左移运算符重载；
                              （2）语法：先创建一个类，创建一个全局重载函数，在重在函数中对于左移运算符进行重新定义，返回ostream&类型（这样做是为了能在输出后添加其它内容，如换行）；代码如下：
#include<iostream>
#include<string>
using namespace std;

class person {
public:
	int m_a;
	int m_b;
};

ostream &operator<<(ostream &cout, person& p) {
	cout << p.m_a << " " << p.m_b;
	return cout;
}

int main() {
	p1.m_a = 15;
	p1.m_b = 10;
	person p1;
	cout << p1 << endl;
}

4、递增运算符重载：（1）内置输出：在进行输出的时候，如果是cout<<++b<<endl,属于前置递增，变量b会先进行递增之后进行输出。如果是cout<<b++<<endl;这样会先进行输出的操作，之后进行递增的操作
（2）前置递增：首先对于左移运算符进行重载，再对于递增运算符进行重载。代码如下：
#include<iostream>
using namespace std;

class intager {
public:
	intager() {
		a = 0;
	}
	friend ostream& operator<<(ostream& cout, intager& p);
	friend intager& operator++(intager& sum);
private:
	int a;

};

ostream& operator<<(ostream &cout,intager &p) {
	cout << p.a;
	return cout;
}

intager& operator++(intager& sum) {
	sum.a++;
}

int main() {
	intager manger;
	++manger;
	cout << manger << endl;

}
（3）后置递增：与前置递增相同，后置递增先进行左移运算符重载，在创建一个递增运算符重载；不同的是需要再参数列表中创建一个站位运算符；代码如下：
#include<iostream>
using namespace std;

class Data {
public:
	Data() {
		m_a = 0;
	}
	friend ostream& operator<<(ostream& cout, const Data& p);
	Data operator++(int) {
		Data temp = *this;
		m_a++;
		return temp;
	}
private:
	int m_a;
};

ostream& operator<<(ostream& cout, const Data& p) {         //这里需要使用const使其变为常量，避免了变量的引用，从而避免二义性的产生
	cout << p.m_a;
	return cout;
}

int main() {
	Data manger;
	cout << manger++ << endl;
}
注意的点：在进行左移运算符重载和其他运算符重载进行合并视同的时候，需要对保持变量的一致性，否则会导致二义性的产生，如上边的例子，后置递增返回的是一个值，而左移运算符重载返回的却是引用，导致二义性的产生，因此在进行左移运算符重载的时候要引用常量进行避免。
5、赋值运算符重载：（1）适用的场景：在函数中对于一个对象的成员函数的值赋值给另一个对象，之后用析构函数对于堆区变量进行清除的时候出现了，运行出现了崩溃，因为一个对象指向的是堆区的变量，而另一个被赋值的对象，它也指向和该堆区变量，此时，析构函数会对其进行两次删除，即重复删除的问题，因此要使用赋值运算符重载进行解决，即创建一个新的堆区，让被赋值对象指向该堆区，避免了重复删除的问题。
（2）首相在类中创建一个在堆区的变量，之后进行赋值运算符重载，先删除被赋值对象的堆区变量，再使其重新指向一个新的堆区变量，避免了重复删除的问题，返回被赋值对象；代码如下：
#include<iostream>
using namespace std;

class person {
public:
	person(int age) {
		m_age = new int(age);
	}
	person& operator=(const person& p1) {         //必须为成员函数
		if (this != &p1) {
			delete m_age;                         //删除该对象的原堆区值
			m_age = NULL;

			m_age = new int(*p1.m_age);          //该对象的指针指向新的堆区，而新的堆区中的变量的值是和p1保持一致
		}		return *this;                    //返回被赋值对象的引用，从而可以进行连续赋值的操作
	}
	~person() {
		delete m_age;
	}
	int* m_age;
};

void test() {
	person sum1(15);
	person sum2(14);
	person sum3(12);
	sum2 = sum3 = sum1;
	cout <<* sum1.m_age << *sum3.m_age << endl;
}
6、比较运算符重载：代码如下：
include<iostream>
using namespace std;

class person {
public:
	person(string p1, int p2) :m_name(p1),m_age(p2) {

	}
	bool operator!=(person& s1) {
		if (this->m_age != s1.m_age) {
			return true;
		}
		else {
			return false;
		}
	}
private:
	string m_name;
	int m_age;
};

void test() {
	person sum1("Tom", 17);
	person sum2("Jerry", 17);
	if (sum1 != sum2) {
		cout << "两人年龄不一样大" << endl;
	}
	else {
		cout << "两人年龄一样" << endl;
	}
}

int main() {
	test();

}
7、函数调用运算符重载（仿函数）：（1）作用：仿函数（Function Object）是一种行为类似于函数的对象，它是一个重载了函数调用运算符 operator() 的类实例。仿函数可以像普通函数一样被调用，可以接受参数，也可以有返回值。这种特性使得仿函数在STL（标准模板库）和其他一些编程场景中很有用处。仿函数提供了一种在对象中封装函数行为的方式，使得代码更加模块化、灵活，并可以更好地支持泛型编程。
（2）泛型编程：泛型编程是一种编程范式，其核心思想是编写可以在不同数据类型上工作的代码。泛型编程的目标是编写高度通用、灵活、可重用的代码，以适应各种数据类型和数据结构。

在泛型编程中，程序员通常会使用参数化类型（通常称为模板）来表示算法或数据结构中的元素类型。这使得可以在编写代码时不指定具体的数据类型，而在使用时根据需要进行实例化。这种灵活性使得可以创建更加通用和可复用的代码。

在C++中，泛型编程的主要实现方式是使用模板。例如，C++的标准模板库（STL）提供了一组泛型数据结构和算法，如向量、列表、排序、搜索等，可以适用于各种数据类型。
（3）实例代码如下：
#include<iostream>
using namespace std;

class person {
public:
	person& operator()(person &p1) {
		this->a = p1.a;
		return *this;
	}
	int a;
};

void test() {
	person s1;
	s1.a = 15;
	person s2;
	s2(s1);
	cout << s2.a << endl;
}

int main() {
	test();
}

多态
1、种类：（1）静态多态：函数重载和运算符重载，复用函数名
               （2）动态多态：派生类和虚函数实现运行时的多态
2、区别：静态多态的函数地址早绑定，编译阶段确定。动态多态函数地址晚确定，运行阶段确定。
3、多态的特征：（1）是继承关系
                        （2）子类重写父类的虚函数
4、使用方法：父类的引用或指针，执行子类对象
5、基本使用:代码演示如下：
#include<iostream>
using namespace std;

class people {
public:
	virtual void name() {
		cout << "这个人是谁" << endl;
	}

};

class Tom:public people {
	void name() {
		cout << "这个人是Tom" << endl;
	}

};

class Jerry :public people {
	void name() {
		cout << "这个人是Jerry" << endl;
	}
};

void test(people& p1) {                             //采用的是父类的引用来实现多态
	p1.name();
}

int main() {
	Tom tom;
	test(tom);

}
 	
6、采用父类的引用和指针来实现多态的代码展示：
#include<iostream>
using namespace std;

class calculator {
public:

	virtual int result() {
		return 0;
	}

	int m_a;
	int m_b;
};

class Addcalculator:public calculator {
	int result() {
		return m_a + m_b;
	}
};

class subcalculator :public calculator {
	int result() {
		return m_a - m_b;
	}
};

int test(calculator &p1) {
	return p1.result();
}


int main() {
	Addcalculator sum1;
	sum1.m_a = 10;
	sum1.m_b = 10;
	cout << test(sum1) << endl;
	calculator* sum2 = new Addcalculator;
	sum2->m_a = 15;
	sum2->m_b = 15;
	cout << sum2->result() << endl;
	delete sum2;
}


7、纯虚函数和抽象类
（1）父类中的虚数通常是没有意义的，因此可以将其改写为纯虚数；
（2）语法：virtual 返回值类型 函数名（参数列表）=0；
（3）抽象类：当类中有了纯虚数，这个类成为抽象类。
（4）抽象类的特点：不能实例化对象；子类必须重写纯虚函数，否则也属于抽象类。
（5）注意事项：在抽象类中尽量不要加一些其它的东西，如成员函数，否则会报错。
（6）代码实现实例：#include<iostream>
using namespace std;

class person {
public:
	virtual void age() = 0;
};

class Tom :public person {
public:
	void age() {
		cout << "15" << endl;
	}
};

void test() {
	person* sum1 = new Tom;
	sum1->age();
	
}
void test1(person& p1) {
	p1.age();
}

int main() {
	Tom tom;
	test();
	test1(tom);
}

8、虚析构和纯虚析构：
（1）使用原因：当我们在使用父类指针指向子类对象的时候，在子类中添加的堆区内容并不会被父类指针释放，造成堆区内存的泄漏
（2）虚析构的语法：在父类析构函数前加“virtual”
（3）纯虚析构：语法展示：在虚析构的前提下去掉花括号，加上等于零；在父类外，需要对于析构函数进行实现，因为父类中可能也存在一些堆区数据需要释放。
                        注意：与纯虚函数不同，纯虚析构函数不经需要声明，同时也需要实现；还有一点，有纯虚析构的类也成为抽象类。代码演示如下：
#include<iostream>
using namespace std;

class person {
public:
	person() {
		cout << "父类构造函数" << endl;
	}
	virtual void age() {
		cout << "虚函数" << endl;
	}
	virtual ~person() = 0;
};

person::~person() {
	cout << "父类的析构函数" << endl;
}
class Tom:public person {
public :
	Tom(string name) {
		cout << "子类的构造函数" << endl;
		m_name = new string(name);
	}
	void age() {
		cout << "子类的函数" << endl;
	}
	string *m_name;
	~Tom() {
		if (m_name != NULL) {
			delete m_name;
			m_name = NULL;
			cout << "子类的析构函数" << endl;
		}
	}
};

void test() {
	person* sum1 = new Tom("name");
	sum1->age();
	delete sum1;                                               //一定要进行释放，否则编译器认为其生命周期还没有结束，不会使用类中的析构函数进行内存的释放，可能导致内存的泄漏
}
int main() {
	test();

c++文件操作
1、（1）意义：程序运行时的数据都是临时数据，程序结束后会自动释放。通过文件可以将数据持久化。
     （2）文件的分类：一个是文件文本：文件以文本的ASCLL码形式存入到计算机中。二是二进制文本：文件以文本二进制存入到计算机中，用户一般无法直接读懂它。
2、操作：（1）首先在c++中对于文件进行操作需要包含头文件<fstream>
              然后，操作文件可以分为三大类：<ofstream>写操作，<ifstream>读操作，<fstream>读写操作。
             （2）步骤：1、包含头文件：#include<fstream>
                               2、创建流对象：ofstream ofs;
                               3、打开文件：ofs.open("文件路径"，打开方式)；
                               4、写数据：ofs<<"写入数据"；
                               5、ofs.close();
3、2、（2）中的打开方式有：ios::in        为读文件而打开文件
                                           ios::out      为写文件而打开文件
                                           ios::ate      初始化位置：文件尾
                                           ios::app     追加方式写文件
                                           ios::trunc   如果文件存在先删除，再创建
                                           ios::binary  二进制书写
4、注意：文件的打开方式可以配合使用，利用“|”操作符
              文件如果没有标明路径，则默认保存到临时编写文件夹中
5、读文件：步骤：1、包含头文件。2、创建流对象。3、打开文件，并判断是否成功。
                           4、读数据：第一种：char buf[1024]={0}      //创建一个字符数组，并将所有字符初始化为0
                                                         while(ifs>>buf){cout<<buf<<endl;}    //将ifs读取到的数据录入到buf数组中，并作为while循环的判断条件，在while循环中输出buf，即输出读入的数据。代码演示：
                                             第二种：	char sum[1024] = { 0 };  
	while (ifs.getline(sum, sizeof(sum))) {              //利用读文件中的录入，即ifs.getline(录入位置，预留的空间)
		cout << sum << endl;
	}
                                             第三种：
	string buf;
	while (getline(ifs, buf)) {              //要在最前边加上#include<string>，getline（录入文件名，录入空间名）在string文件中
		cout << buf << endl;
}
                                            第四种：（不推荐，因为是一个一个去录入）
	char a;
	while ((a = ifs.get())!=EOF) {
		cout << a;
	}
6、二进制写文件：#include<iostream>
#include<fstream>
using namespace std;

class person {
public:
	char m_name[64];                                 //创建一个类
	int age;
};

void test() {
	ofstream ofs{ "test.txt",ios::out | ios::binary };            //文件打开形式为写文件和二进制
	person sum1 = { "王五",19 };                                  //创建一个person对象
	ofs.write((const char*)&sum1, sizeof(sum1));                 //将文件强制转化为二进制
	ofs.close();
}

int main() {
	test();
}
7、读取二进制文件：
#include<iostream>
#include<fstream>
using namespace std;

class person {
public:
	char m_name[64];                                 //创建一个类
	int age;
};

void test1() {
	ifstream ifs("test.txt", ios::in | ios::binary);     //相当于一个接口，确定读入的文件
	if (!ifs.is_open()) {
		cout << "文件读取失败" << endl;
		return;
	}
	person p1;                                          //用来录入的对象（将二进制写的对象的内容录入到这个对象中）
	ifs.read((char*)&p1, sizeof(person));
	cout << p1.age << " " << p1.m_name << endl;
	ifs.close();
	
}

int main() {
	test1();
}
                     
                                                                  