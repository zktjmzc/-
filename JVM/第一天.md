---
date: 2025-08-20
aliases:
  - 黑马JVM[1-16]
tags:
  - JVM
  - jvm、jdk、jre的关系
  - 虚拟机栈
  - 栈帧
  - 栈内存溢出
  - 线程运行诊断
  - jstack
  - 本地方法栈
---
# JVM
## 初识
---
#### 1、简介
	java虚拟机，java程序（java二进制字节码的运行环境）的运行环境
#### 2、优势
	一次编写，导出运行
	自动内存管理机制，垃圾回收功能
	数组下标越界检查：如果不管，可能会覆盖其它代码的内存
	多态：JVM使用虚方法表的机制实现
#### 比较（jvm、jdk、jre）
![[Pasted image 20250820134956.png]]
###### 注：JVM不唯一，常用的是甲骨文提供的HotSpot
### 3、JVM构成
![[Pasted image 20250820135827.png]]

## 程序计数器
---
	作用：在程序执行的过程中，记住下一条JVM指令的执行地址
![[Pasted image 20250820140638.png]]
	流程：
		首先，源码转为二进制字节码，即JVM指令
		然后，交给解释器，解释器将其转化为机器码，交给CPU处理
		在此过程中，程序计数器在这个过程中，记录下一条jvm指令的位置
		解释器处理完后，向程序计数器询问下一条JVM指令的地址
	存储位置：寄存器
	特点：
		线程私有，每个线程都有自己的程序计数器，
		不会出现内存溢出
### 虚拟机栈
---
	定义：线程运行时需要的内存空间
#### （1）栈帧
	程序运行时，其中每个方法所需要的空间称为栈帧
	栈帧是存储在虚拟栈
	执行完毕会释放
	每个线程只能有一个活动栈帧，对应着正在执行的那个方法
#### （2）问题解析
内存回收是否会涉及栈内存？
	不涉及，因为产生的内存调用是一次次方法调用产生的栈帧，而方法执行完后，栈帧会自动释放
栈内存分配越大越好吗？
	栈内存在出Windows外的主流操作系统中大小固定为1024kb，而Windows视情况而定
	不是，越大线程数会减少，且不会提速，可以更多次的方法的递归调用
方法内的局部变量是否线程安全？
	局部变量是线程私有的，不会出现局部变量受到其它线程干扰的情况
	全局变量，由于是所有线程共享的，所以可能会出现线程安全的问题，加保护机制
举例
![[Pasted image 20250820150017.png]]
##### 即变量是否逃离方法的作用范围，例如，参数和返回值

### 栈内存溢出（stackOverflowError）
---
#### 产生原因
	1、栈帧过多导致栈内存溢出，例如，递归调用
	2、栈帧过大（少见）
	3、第三方库的不当调用，例如，对象循环调用，此时使用Jackson会出现栈溢出

## 线程运行诊断
---
### 1、CPU占用过多
	定位
		用top命令，查看那个进程占用大量CPU，
		用ps | grep 进程号 锁定线程
	诊断
		用jstack 进程id 打开线程的内部
		在根据刚才查到的线程id，转化为16进制，找到该线程
		根据提示，找到问题行数
### 2、程序运行很长时间没有结果
	先查询该进程的id
	使用jstack 进程id，通过给出的信息，找到对应的线程
	其会提过问题的位置和可能的错误原因，例如，可能是死锁
## 本地方法栈
----
#### 定义
用来存储调用的本地方法的站，本地方法指的java无法直接调用底层方法，而是借用c/c++来间接使用。
#### 特征
方法声明中显示native的，例如，Object中的clone方法