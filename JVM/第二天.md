---
date: 2025-08-21
aliases:
  - 黑马JVM
tags:
  - 堆
  - 方法区
  - 串池（StringTable）
  - intern（）方法
  - 常量池
  - 串池
  - 直接内存
  - unsafe
  - NIO
  - 垃圾回收
  - 循环引用法
  - 可达性分析法
---
## 堆（Heap）
---
#### 1、 定义
	只要是new出来的对象都会使用堆
	它是线程共享的，堆中的对象要考虑线程安全的问题
	有垃圾回收机制
#### 2、堆内存溢出问题
堆内存错误标识
![[Pasted image 20250821074001.png]]
	产生情况：
		短时间内在内存中创建了过多的对象，一次性加载到内存中，例如数据库上百万条数据放入List集合。
		大对象被频繁创建
		内存泄漏，某些对象虽已不再使用，但依然引用，导致gc无法回收
			静态类集合存放对象但不清理
			缓存实现不合理
			各种监听器、回调不注销
			使用ThreadLocal，没用正确调用remove（），线程长期存活数据无法释放
			使用不当的数据结构：
				HashMap错误使用，哈希冲突严重，链表/红黑树过长
				不断往List或Map中放数据，不释放无用数据
#### 3、堆内存诊断
	工具：
		jps：查看系统中有哪些java进程
		jmap：查看堆内存占用情况，jmap -heap 进程id
		jconsole：多功能检测工具，可以连续监测
## 方法区
---
#### 1、定义
用来存储与==类相关==的元数据信息，jvm规范中有明确定义，不同jvm实现方式和叫法上可能有所差异
#### 2、特点
属于==线程共享==的内容
#### 3、存储内容
	已经被jvm加载的结构信息
	成员变量信息
	方法信息
	字节码指令
	运行时常量池
### 4、方法区、堆、栈的区别
方法区：线程共享、“类级别”，类模版数据
堆：线程共享，存放对象实例，是GC的主要区域
栈：线程私有，用来存储方法调用的局部变量、返回地址
#### 5、HotSpot JVM的实现
在jdk7之前，是通过==永久代==实现的，位于堆内存中，大小固定，容易PermGen space
jdk8之后，实现变成了==元空间==，位于本地内存中，大小无限，可能会Metaspace
#### 6、方法区内存溢出
当方法区中存储了过多量的类，方法区内存溢出
### 常量池
	定义：虚拟机指令根据常量池找到类名、方法名、参数类型，字面信息等
	运行时常量池：当类被加载时，放入运行时常量池，并把里面的符号变为真实地址
### 串池和常量池的关系
字符串对象刚一开始会加载到常量池中，不会变为字符串对象，当被使用到的时候才会被创建为字符串对象，并放入串池中。

## StringTable
---
### 1、演示
![[Pasted image 20250821094128.png]]
### 2、intern（）
作用：尝试将字符串放入串池中
案例
![[Pasted image 20250821094958.png]]
注意：在jdk6之前，放入的字符串对象如果串池没有，则会复制一份放入串池，而不是本体放入，
	此时，就算串池中本来没有s，依然s2!=s
### 3、存储位置
	在jdk8之后，由于方法区放在了本地位置，此时StringTable存放在了堆中，提高效率
#### 4、垃圾回收
	当串池中存入了大量数据，而其中的数据又是大量的无用信息，此时，会触发垃圾回收机制，将长时间没
	没有被使用到的字符串进行垃圾回收
#### 5、性能调优
	1、串池本质是一个哈希表，当桶个数较少的时候，很容易出现==哈希冲突==的问题，增加存入的时间。
	2、考虑字符串对象是否入池，例如，使用intern方法，保证一个字符串对象在串池中只有一个

##  直接内存
---
#### 1、定义
	属于操作系统的内存，受操作系统的控制
### 2、作用
	常见于NIO操作，作为数据缓冲区
### 3、特点
	读写新能高，回收代价高
	不受JVM的管理
### 4、NIO
	具有非阻塞I/O能力
	作用：
		多路复用
		缓冲区
		通道
	核心组件
		Buffer：不同于BIO基于流的直接读写，其基于缓冲区，数据先写入Buffer中，再从中读出
		Channel：类似于流，是双向的，可读可写
		Selector：多路复用器，允许一个线程同时监听多个通道事件，避免一连接一线程的高开销问题
	使用场景
		高并发网络服务器、高新能读写、游戏服务器
	内存溢出解决
		在相关的Buffer对象中，会调用unsafe中的allocateMemory方法，完成对于直接内存的分配
		而当Buffer对象被回收时，其类中的虚引用对象Cleaner会执行clean方法，而方法中会执行任务
		任务对象，而任务对象会调用unsafe的freeMemory方法，释放直接内存。
### 5、限制
	当使用-xx:+DisableExplicitGc关闭显示gc，即system.gc（），内存溢出的解决方式无法生效
	解决方案
		直接在对应要释放直接内存的地方，调用unsafe.freeMemory方法
## 垃圾回收
---
### 1、如何判断对象是否可以回收
	1、循环引用法：当对象被引用一次计数器就加一，如果为零，则可以被回收
			带来的问题：循环引用，无法被释放
	2、可达性分析算法：扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，找不到就回
		收
### 2、可达性分析算法
	GC Root对象：
		系统类
		操作系统方法引用的java对象
		被加锁对象
		活动线程中的对象
	