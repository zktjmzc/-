---
date: 2025-08-28
aliases:
  - 黑马Redis[75-71]
tags:
  - 锁重置
  - 看门狗机制
  - 主从一致性
  - 锁链
  - 异步秒杀
  - 异步下单
---
## 锁重试和看门狗机制
---
### （1）锁重置
	底层原理：
		调用时会传最大重试时间，tryLock方法会在等待时间内不断尝试获取锁，直到成功或失败
		会根据线程id去组key，利用Lua脚本去尝试获得锁，如果获取成功，则返回null，如果失败，则
		返回TTL，调用订阅函数，等待占有锁的线程释放锁的信号，判断最大等待时间和TTL谁大，若TTL
		更大，则返回false，反之，则当收到释放锁的信号，再次尝试获取锁，
### （2）看门狗机制
	底层原理：
		当没有传自动锁释放时长是，Redisson底层内置了默认30秒的leaseTime，若没有提供
		leaseTIme，则Redisson会启动一个定时任务，每隔leaseTime/3去检测持有锁的的线程
		是否还活着，活着自动给锁续30秒，挂掉或宕机，锁会自然释放。
		当正常结束任务后，会释放锁，也会将看门狗关闭
	避免锁因过期而误释放。
## 主从一致性
### （1）解决的问题
	当客户端A从master上获取锁，还没来得及传给从节点，此时master挂掉，客户端B从新的master中获取
	锁，此时，出现多个客户端拥有锁的严重问题
### （2）解决方案（Redlock算法）
	在N台Redis节点（最好物理机不同）上，尝试获取同一把锁
	只要超过一半的节点上获取成功，就算锁成功
	释放锁时，需要所有节点都释放锁，避免个别节点宕机或数据延迟，保障大多数节点的主从一致性
	注：至少三台及以上的Reids节点

## 异步秒杀
---
### （1）整体流程
![[Pasted image 20250828094304.png]]
### （2）业务流程
![[Pasted image 20250828095458.png]]
### （3）改进秒杀业务，提高并发性能
	Lua脚本
```lua
--1、参数列表  
--1.1 优惠券id  
local voucherId = ARGV[1]  
--1.2 用户id  
local userId = ARGV[2]  
  
--2、数据key  
--2.1 库存key  
local stockKey = 'seckill:stock:' .. voucherId  
--2.2 订单key  
local orderKey = 'seckill:order:' .. voucherId  
  
--3、脚本业务  
--3.1 判断库存是否充足get stockKey  
if (tonumber(redis.call('get', stockKey)) <= 0) then  
    --3.2 库存不足,返回1  
    return 1  
end  
--3.2 判断用户是否下单  
if (redis.call('sismember', orderKey, userId) == 1) then  
    --存在说明是重复下单  
    return 2  
end  
--3.3扣库存 incrby stockKey-1redis.call('incrby',stockKey,-1)  
--3.4添加用户 sadd orderKey userIdredis.call('sadd',orderKey,userId)  
return 0
```
	VoucherService（添加库存）
```java
@Override  
@Transactional  
public void addSeckillVoucher(Voucher voucher) {  
    // 保存优惠券  
    save(voucher);  
    // 保存秒杀信息  
    SeckillVoucher seckillVoucher = new SeckillVoucher();  
    seckillVoucher.setVoucherId(voucher.getId());  
    seckillVoucher.setStock(voucher.getStock());  
    seckillVoucher.setBeginTime(voucher.getBeginTime());  
    seckillVoucher.setEndTime(voucher.getEndTime());  
    seckillVoucherService.save(seckillVoucher);  
    //保存秒杀库存，保存到Redis中  
    redisTemplate.opsForValue().set(RedisConstants.SECKILL_STOCK_KEY +voucher.getId(), String.valueOf(voucher.getStock()));  
}
```
	voucherOrderService
```java
/**  
 * 下单秒杀券  
 * @param voucherId  
 * @return  
 */  
public Result secKillVoucher(Long voucherId) throws InterruptedException {  
    Long userId = UserHolder.getUser().getId();  
    //1、执行Lua脚本  
    Long result = redisTemplate.execute(  
            SECKILL_SCRIPT,  
            Collections.emptyList(), //没有key，传空  
            voucherId.toString(),  
            userId.toString()  
    );  
    //2、判断是否有购买资格  
    int num = result.intValue();  
    if(num!=0){  
        return Result.fail(num==1?"库存不足":"一人一单");  
    }  
    //3、有购买资格，将下单信息存放到阻塞队列中  
    long orderId = redisIdWorker.nextId("order");  
    //TODO：保存到阻塞队列  
  
    //4、返回订单Id  
    return Result.ok(orderId);  
}
```
### (4)异步下单
	思路：
		先利用Redis完成库存余量，一人一单判断，完成抢单判断
		再将下单业务放入阻塞队列，利用独立线程异步下单
	带来的问题：
		内存限制：阻塞队列调用的是JDK中的阻塞队列，占据的是JVM的内存，可能导致内存溢出
		数据安全：Redis若出现问题，则可能导致抢单数据的丢失
```java
@Slf4j  
@Service  
public class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements IVoucherOrderService {  
  
    @Autowired  
    private ISeckillVoucherService seckillVoucherService;  
  
    private final SnowflakeIdWorker snowflakeIdWorker=new SnowflakeIdWorker(29,20);  
  
    @Autowired  
    private RedisIdWorker redisIdWorker;  
  
    @Autowired  
    private StringRedisTemplate redisTemplate;  
  
    @Autowired  
    private RedissonClient redissonClient;  
  
    private static final DefaultRedisScript<Long> SECKILL_SCRIPT;  
    static {  
        SECKILL_SCRIPT =new DefaultRedisScript<>();  //在代码快中初始化，只需要初始化一次，提高性能  
        SECKILL_SCRIPT.setLocation(new ClassPathResource("seckill.lua")); //脚本加载位置  
        SECKILL_SCRIPT.setResultType(Long.class);  //返回值的结果类型  
    }  
    //添加阻塞队列（当队列中没有元素，线程会进入阻塞）  
    private BlockingQueue<VoucherOrder> orderTasks=new ArrayBlockingQueue<>(1024*1024);  
    //创建线程池(单线程)  
    private static final ExecutorService SECKILL_ORDER_EXECUTOR= Executors.newSingleThreadExecutor();  
  
    @PostConstruct   //注解：一但该类初始化完成就会执行该方法  
    private void init(){  
        SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());  
    }  
    //内部类，设置线程任务  
    private class VoucherOrderHandler implements Runnable{  
  
        @Override  
        public void run() {  
            while (true){  
                //1、获取队列中的订单信息  
                try {  
                    VoucherOrder order = orderTasks.take();  
                    //2、创建订单  
                    handleVoucherOrder(order);  
                } catch (Exception e) {  
                    log.error("处理订单异常",e);  
                }  
            }  
        }  
    }  
  
    private void handleVoucherOrder(VoucherOrder order) {  
        Long userId = order.getUserId();  
        //获取锁（可重入），指定锁的名称  
        RLock lock = redissonClient.getLock("lock:order:" + userId);  
        //尝试获取锁，参数分别为：最大等待获取时间，锁自动释放时间，时间单位  
        //参数默认值：-1（失败不等待） 30秒后自动释放  
        boolean isLock = lock.tryLock();  
        //判断是否获取锁成功  
        if(!isLock){  
            //获取锁失败，返回错误信息或重试  
            log.error("不允许重复下单");  
        }  
        try {  
            proxy.createVoucherOrder(order);  
        } finally {  
            lock.unlock();  //一定要释放锁  
        }  
    }  
    private IVoucherOrderService proxy;  
  
    /**  
     * 下单秒杀券  
     * @param voucherId  
     * @return  
     */  
    public Result secKillVoucher(Long voucherId) throws InterruptedException {  
        Long userId = UserHolder.getUser().getId();  
        //1、执行Lua脚本  
        //查询商品是否还有存量，用户是否一人一单  
        Long result = redisTemplate.execute(  
                SECKILL_SCRIPT,  
                Collections.emptyList(), //没有key，传空  
                voucherId.toString(),  
                userId.toString()  
        );  
        //2、判断是否有购买资格  
        int num = result.intValue();  
        if(num!=0){  
            return Result.fail(num==1?"库存不足":"一人一单");  
        }  
        //3、有购买资格，将下单信息存放到阻塞队列中  
        //创建订单  
        VoucherOrder voucherOrder = new VoucherOrder();  
        //订单id  
        long orderId = redisIdWorker.nextId("order");  
        voucherOrder.setId(orderId);  
        //用户id  
        voucherOrder.setUserId(userId);  
        //代金券id  
        voucherOrder.setVoucherId(voucherId);  
        //放入到阻塞队列，交给异步线程去处理  
        orderTasks.add(voucherOrder);  
        //获取代理对象  
        proxy = (IVoucherOrderService) AopContext.currentProxy();  
        //4、返回订单Id  
        return Result.ok(orderId);  
    }  
  
    @Transactional  
    public void createVoucherOrder(VoucherOrder order) {  
        //4、一人一单  
        Long userId = order.getUserId();  
        //4.1 查询订单  
        int count = query().eq("user_id", userId).eq("voucher_id", order.getVoucherId()).count();  
        //4.2 判断是否存在  
        if(count>0){  
            //不能够重复购买  
            log.error("一人一单");  
            return;  
        }  
        //5、扣减库存  
        boolean success = seckillVoucherService.update()  
                .setSql("stock=stock-1")  
                .eq("voucher_id", order.getVoucherId())  
                .gt("stock",0)  //乐观锁：CAS法  
                .update();  
        if(!success){  
            log.error("库存不足");  
        }  
        save(order);  
    }  
}
```