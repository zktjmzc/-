---
date: 2025-08-25
aliases:
  - 黑马Redis[35-47]
tags:
  - 用户查询缓存
  - 互斥锁
  - 逻辑过期
  - 缓存穿透
  - 缓存击穿
  - 缓存更新策略
---
## 商户查询缓存
---
#### 1、缓存
	1、优势：
		降低后端负载
		提高读写速率，降低响应时间
	2、缺点
		数据一致性
		增加代码维护成本
		运维成本
### 2、添加缓存操作
	Controller层
```java
@RestController  
@RequestMapping("/shop-type")  
public class ShopTypeController {  
    @Resource  
    private IShopTypeService typeService;  
  
    @Autowired  
    private IShopTypeService shopTypeService;  
  
    @GetMapping("list")  
    public Result queryTypeList() {  
//        List<ShopType> typeList = typeService//                .query().orderByAsc("sort").list();  
        return typeService.listType();  
    }  
}
```
	Service层
```java
@Service  
public class ShopTypeServiceImpl extends ServiceImpl<ShopTypeMapper, ShopType> implements IShopTypeService {  
    @Autowired  
    private StringRedisTemplate redisTemplate;  
  
    @Override  
    public Result listType() {  
        String key="cache:type";  
        //1、向查询redis  
        String s = redisTemplate.opsForValue().get(key);  
        //2、存在，直接返回  
        if(StrUtil.isNotBlank(s)){  
            List<ShopType> list = JSONUtil.toList(s, ShopType.class);  
            return Result.ok(list);  
        }  
        //3、不存在，查找数据库  
        List<ShopType> typeList = query().orderByAsc("sort").list();  
        //4、不存在，返回错误  
        if(typeList.isEmpty()){  
            return Result.fail("商品种类为空");  
        }  
        //5、存在，存入缓存  
        redisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(typeList));  
        //6、返回结果  
        return Result.ok(typeList);  
    }  
}
```
### 3、缓存更新策略
#### （1）策略种类
		1、内存淘汰：
			当内存不足时，Redis会自动淘汰部分数据，下次查询时更新缓存（自动）
			难以保障一致性
			没有维护成本
		2、超时剔除
			给缓存数据添加TTL时间，到期后自动删除缓存，下次查询时更新
			一致性一般
			维护成本低
		3、主动更新
			编写业务逻辑，数据库更新时，自动更新缓存
			一致性好
			维护成本较高
#### （2）缓存和数据库操作需要考虑的问题
	1、数据库发生变化时，缓存应当如何处理
		采用删除缓存的策略，避免频繁操作数据库，而缓存也频繁更改
	2、怎么保证一致性问题
		单体系统，将数据库和缓存操作作为事务绑定在一起
		分布式系统：利用TCC等分布式事务方案
	3、数据库和缓存谁先操作
		（1）先删缓存，在更新数据库
		带来的问题：当删完缓存，而此时，另一个线程在没有找到缓存，去寻找数据库，而数据库还没有更
				新，将没更新前的数据写入缓存，导致数据不一致的情况（概率较高）
		（2）先更新数据库，后删除缓存（更优）
		带来的问题：当一个线程，要查询的时候，缓存正好TTL耗尽，其去查询数据库，此时数据库先更
				更新完后，删除缓存，此时，查询的线程只好将旧的数据库数据写入缓存，数据不一致
				（较为少见）
#### （3）代码实现
	Service层
```java
/**  
 * 更新数据库和对应缓存  
 * @param shop  
 * @return  
 */  
@Transactional  
public Result update(Shop shop) {  
    //1、更新数据库  
    updateById(shop);  
    if(shop==null){  
        return Result.fail("商铺信息有误");  
    }  
    //2、删除缓存  
    redisTemplate.delete(RedisConstants.CACHE_SHOP_KEY+shop.getId());  
    return Result.ok();  
}
```

#### （4）缓存击穿的解决方案
	1、采用互斥锁的解决方案
	代码实现
```java
@Autowired  
private StringRedisTemplate redisTemplate;  
/**  
 * 根据商品id进行查询，并进行缓存  
 * @param id  
 * @return  
 */  
public Result queryById(Long id) {  
    //缓存穿透问题的解决  
    //Shop shop = queryWithPassThrough(id);  
  
    //互斥锁解决缓存击穿  
    Shop shop = queryWithMutex(id);  
    if (shop==null){  
        return Result.fail("店铺不存在");  
    }  
    return Result.ok(shop);  
}  
  
public Shop queryWithMutex(Long id){  
    //1、查询redis中是否存在  
    String key= RedisConstants.CACHE_SHOP_KEY+id;  
    String s = redisTemplate.opsForValue().get(key);  
    //2、存在直接返回  
    if(StrUtil.isNotBlank(s)){  
        Shop shop = JSONUtil.toBean(s, Shop.class);  
        return shop;  
    }  
    //空字符串，直接返回错误  
    if(s!=null){  
        return null;  
    }  
    //3、实现缓存重建  
    String lockKey= null;  
    Shop shop = null;  
    try {  
        //3.1 获取互斥锁  
        lockKey = "lock:shop:"+id;  
        boolean isLock = tryLock(lockKey);  
        //3.2 是否获取成功  
        if(!isLock){  
            //3.3 获取失败  
            Thread.sleep(50);  
            return queryWithMutex(id);  
        }  
        //3.4 获取锁成功  
        //4、不存在，查询数据库  
        shop = getById(id);  
        //5、数据库不存在，返回错误  
        if(shop==null){  
            //将空值存入数据库，防止内存穿透  
            redisTemplate.opsForValue().set(key,"",RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES);  
            return null;  
        }  
        //6、存在，存入redis中  
        redisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);  
    } catch (InterruptedException e) {  
        throw new RuntimeException(e);  
    } finally {  
        //7、释放锁  
        unlock(lockKey);  
    }  
    // 8、将查询的数据返回  
    return shop;  
}
private boolean tryLock(String key){  
    Boolean flag = redisTemplate.opsForValue().setIfAbsent(key, "1", RedisConstants.LOCK_SHOP_TTL, TimeUnit.SECONDS);  
    //防止直接传，拆箱过程中出现空指针的问题  
    return BooleanUtil.isTrue(flag);  
}  
  
private void unlock(String key){  
    redisTemplate.delete(key);  
}
```
注：==这里可以使用Jmeter进行多线程模拟，也可以使用Apifox的自动化测试==
	2、使用逻辑过期方式
	流程展示
![[Pasted image 20250825131942.png]]
	代码展示
	Service层
```java
@Service  
public class ShopServiceImpl extends ServiceImpl<ShopMapper, Shop> implements IShopService {  
  
    @Autowired  
    private StringRedisTemplate redisTemplate;  
    //开大小为10的线程池  
    private static final ExecutorService CACHE_REBUILD_EXECUTOR= Executors.newFixedThreadPool(10);
        /**  
     * 根据商品id进行查询，并进行缓存  
     * @param id  
     * @return  
     */  
    public Result queryById(Long id) {  
        //缓存穿透问题的解决  
        //Shop shop = queryWithPassThrough(id);  
  
        //互斥锁解决缓存击穿  
//        Shop shop = queryWithMutex(id);  
        //逻辑过期解决缓存击穿  
        Shop shop = queryWithLogicalExpire(id);  
        if (shop==null){  
            return Result.fail("店铺不存在");  
        }  
        return Result.ok(shop);  
    }  
  
    //逻辑过期的方法  
    public Shop queryWithLogicalExpire(Long id){  
        //1、查询redis中是否存在  
        String key= RedisConstants.CACHE_SHOP_KEY+id;  
        String s = redisTemplate.opsForValue().get(key);  
        //2、不存在直接返回  
        if(StrUtil.isBlank(s)){  
            return null;  
        }  
        //3、命中先判断过期时间  
        RedisData bean = JSONUtil.toBean(s, RedisData.class);  
        Shop shop = JSONUtil.toBean((JSONObject) bean.getData(), Shop.class);  
        //4、判断是否过期  
        //4.1 未过期，直接返回店铺信息  
        if(bean.getExpireTime().isAfter(LocalDateTime.now())){  
            return shop;  
        }  
        //4.2 已过期，需要缓存重建  
        //5、缓存重建  
        //5.1 获取互斥锁  
        String lockKey=RedisConstants.LOCK_SHOP_KEY+id;  
        //5.2 判断是否获取锁成功  
        boolean lock = tryLock(lockKey);  
        if(lock){  
            //5.2 成功，开启独立线程，实现缓存重建  
            CACHE_REBUILD_EXECUTOR.submit(()->{  
                try {  
                    //重建缓存  
                    this.saveShop2Redis(id,20L);  
                } catch (Exception e) {  
                    throw new RuntimeException(e);  
                } finally {  
                    //释放锁  
                    this.unlock(lockKey);  
                }  
            });  
        }  
        //5、3 返回过期的商品信息  
        return shop;  
    }
    private boolean tryLock(String key){  
    Boolean flag = redisTemplate.opsForValue().setIfAbsent(key, "1", RedisConstants.LOCK_SHOP_TTL, TimeUnit.SECONDS);  
    //防止直接传，拆箱过程中出现空指针的问题  
    return BooleanUtil.isTrue(flag);  
}  
  
private void unlock(String key){  
    redisTemplate.delete(key);  
}  
  
/**  
 * 编写逻辑过期时间的方法,实现缓存预热  
 * @param id  
 * @param expireSeconds  
 */  
public void saveShop2Redis(Long id,Long expireSeconds) throws InterruptedException {  
    //1、查询店铺数据  
    Shop shop = getById(id);  
    //模拟延迟  
    Thread.sleep(200);  
    //2、封装逻辑过期时间  
    RedisData redisData = new RedisData();  
    redisData.setData(shop);  
    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));  
    //3、写入Redis中  
  redisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(redisData));  
}
```
### （5）==缓存工具封装==
	将前边应对三大缓存问题的方法进行封装
```java
/**  
 * 缓存工具封装  
 */  
@Component  
@Slf4j  
public class CacheClient {  
  
    @Autowired  
    private StringRedisTemplate redisTemplate;  
    //开大小为10的线程池  
    private static final ExecutorService CACHE_REBUILD_EXECUTOR= Executors.newFixedThreadPool(10);  
  
    /**  
     * 设置缓存  
     * @param key  
     * @param value  
     * @param time  
     * @param unit  
     */  
    public void set(String key, Object value, Long time, TimeUnit unit){  
        redisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value),time,unit);  
    }  
  
    /**  
     * 设置逻辑过期  
     * @param key  
     * @param value  
     */  
    public void setWithLogicalExpire(String key, Object value,Long time, TimeUnit unit){  
        //设置逻辑过期时间  
        RedisData redisData=new RedisData();  
        redisData.setData(value);  
        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));  
        redisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));  
    }  
  
    //缓存穿透问题的解决  
    //function：有参有返回值的逻辑方法，需要使用者将方法传过来，ID是参数，R是返回值  
    public <R,ID> R queryWithPassThrough(String keyPrefix, ID id, Class<R>type, Function<ID,R>dbFallback,  
                                         Long time, TimeUnit unit){  
        //1、查询redis中是否存在  
        String key= keyPrefix+id;  
        String s = redisTemplate.opsForValue().get(key);  
        //2、存在直接返回  
        if(StrUtil.isNotBlank(s)){  
            JSONUtil.toBean(s, type);  
        }  
        //空字符串，直接返回错误  
        if(s!=null){  
            return null;  
        }  
  
        //3、不存在，查询数据库（从调用者获取的方法中获得结果）  
        R r = dbFallback.apply(id);  
        //4、数据库不存在，返回错误  
        if(r==null){  
            //将空值存入数据库，防止内存穿透  
            redisTemplate.opsForValue().set(key,"",RedisConstants.CACHE_NULL_TTL,TimeUnit.MINUTES);  
            return null;  
        }  
        //5、存在，存入redis中  
        this.set(key,r,time,unit);  
        // 6、将查询的数据返回  
        return r;  
    }  
  
    //逻辑过期的方法  
    public <R,ID>R queryWithLogicalExpire(String prefix,ID id,Class<R>type, Function<ID,R>dbFallback,  
                                          Long time, TimeUnit unit){  
        //1、查询redis中是否存在  
        String key= prefix+id;  
        String s = redisTemplate.opsForValue().get(key);  
        //2、不存在直接返回  
        if(StrUtil.isBlank(s)){  
            return null;  
        }  
        //3、命中先判断过期时间  
        RedisData bean = JSONUtil.toBean(s, RedisData.class);  
        R r = JSONUtil.toBean((JSONObject) bean.getData(),type);  
        //4、判断是否过期  
        //4.1 未过期，直接返回店铺信息  
        if(bean.getExpireTime().isAfter(LocalDateTime.now())){  
            return r;  
        }  
        //4.2 已过期，需要缓存重建  
        //5、缓存重建  
        //5.1 获取互斥锁  
        String lockKey=RedisConstants.LOCK_SHOP_KEY+id;  
        //5.2 判断是否获取锁成功  
        boolean lock = tryLock(lockKey);  
        if(lock){  
            //5.2 成功，开启独立线程，实现缓存重建  
            CACHE_REBUILD_EXECUTOR.submit(()->{  
                try {  
                    //重建缓存  
                    //先查数据库  
                    R r1 = dbFallback.apply(id);  
                    //在写入Redis  
                    this.setWithLogicalExpire(key,r1,time,unit);  
                } catch (Exception e) {  
                    throw new RuntimeException(e);  
                } finally {  
                    //释放锁  
                    this.unlock(lockKey);  
                }  
            });  
        }  
        //5、3 返回过期的商品信息  
        return r;  
    }  
  
    private boolean tryLock(String key){  
        Boolean flag = redisTemplate.opsForValue().setIfAbsent(key, "1", RedisConstants.LOCK_SHOP_TTL, TimeUnit.SECONDS);  
        //防止直接传，拆箱过程中出现空指针的问题  
        return BooleanUtil.isTrue(flag);  
    }  
  
    private void unlock(String key){  
        redisTemplate.delete(key);  
    }  
}
```