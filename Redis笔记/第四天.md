---
date: 2025-08-22
aliases:
  - 黑马Redis[26-50]
tags:
  - Session模式
  - 验证码功能
  - Redis缓存验证码和用户信息
  - Session共享
---
# 短信登录
---
## 基于Session实现登录
### 1、实现流程
![[Pasted image 20250822083032.png]]
### 2、代码实现
#### （1）关于验证的正则表达式（作为工具类）
```java
//RegexPatterns
public abstract class RegexPatterns {  
    /**  
     * 手机号正则  
     */  
    public static final String PHONE_REGEX = "^1([38][0-9]|4[579]|5[0-3,5-9]|6[6]|7[0135678]|9[89])\\d{8}$";  
    /**  
     * 邮箱正则  
     */  
    public static final String EMAIL_REGEX = "^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$";  
    /**  
     * 密码正则。4~32位的字母、数字、下划线  
     */  
    public static final String PASSWORD_REGEX = "^\\w{4,32}$";  
    /**  
     * 验证码正则, 6位数字或字母  
     */  
    public static final String VERIFY_CODE_REGEX = "^[a-zA-Z\\d]{6}$";  
  
}
```

知识点：hutool中字符串的相关方法
判断空值（null、空字符串、全是空格等无效字符串）
```java
//代码片段
if (StrUtil.isBlank(str)) {  
    return true;  
}
```
生成随机数字
```java
//代码片段
//使用随机生成器,生成长度为6位  
String code = RandomUtil.randomNumbers(6);
```
#### （2）发送验证码功能
	Controller层
```java
/**  
 * 发送手机验证码  
 */  
@PostMapping("code")  
public Result sendCode(@RequestParam("phone") String phone, HttpSession session) {  
    //发送手机验证码并保存验证码  
    return userService.sendCode(phone,session);  
}
```
	Service层
```java
/**  
 * 发送并保存验证码  
 * @param phone  
 * @param session  
 * @return  
 */  
public Result sendCode(String phone, HttpSession session) {  
    //1、校验手机号  
    if (RegexUtils.isPhoneInvalid(phone)) {  
        //2、不符合，返回错误信息  
        return Result.fail("手机格式错误");  
    }  
    //3、符合，生成验证码  
    //使用随机生成器,生成长度为6位  
    String code = RandomUtil.randomNumbers(6);  
    //4、保存验证码到Session中  
    session.setAttribute("code",code);  
    //TODO 5、发送验证码  
  
    log.debug("发送短信验证码成功，验证码：{}",code);  
    return Result.ok();  
}
```
#### （3）登录功能
	Controller层
```java
/**  
 * 登录功能  
 * @param loginForm 登录参数，包含手机号、验证码；或者手机号、密码  
 */  
@PostMapping("/login")  
public Result login(@RequestBody LoginFormDTO loginForm, HttpSession session){  
    return userService.login(loginForm,session);  
}
```
	Service层
```java
/**  
 * 登录功能实现  
 * @param loginForm  
 * @param session  
 * @return  
 */  
public Result login(LoginFormDTO loginForm, HttpSession session) {  
    //1、校验手机号和验证码  
    if (RegexUtils.isPhoneInvalid(loginForm.getPhone())) {  
        //2、不符合，返回错误信息  
        return Result.fail("手机格式错误");  
    }  
    //3、根据手机号查询用户信息  
    String code = (String) session.getAttribute("code");  
    //4、判断用户是否存在  
    if(code == null ||!code.equals(loginForm.getCode())){  
        return Result.fail("验证码有误");  
    }  
    //5、用户不存在，创建新用户并保存  
    User user = query().eq("phone", loginForm.getPhone()).one();  
    if (user==null){  
        user=createUserWithPhone(loginForm.getPhone());  
    }  
    //6、保存用户信息到session中  
    session.setAttribute("user",user);  
  
    return Result.ok();  
}
```

#### （4）登录校验功能
	Controller层
```java
    /**  
     * 获取当前的用户并返回  
     * @return  
     */  
    @GetMapping("/me")  
    public Result me(){  
        UserDTO userDTO = UserHolder.getUser();  
//        User user=new User();  
//        BeanUtils.copyProperties(userDTO,user);  
  
        return Result.ok(userDTO);  
    }
```
	拦截器层（interceptor）
```java
public class LoginInterceptor implements HandlerInterceptor {  
    @Override  
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  
        //1、获取Session  
        HttpSession session = request.getSession();  
        //2、获取Session中的用户  
        User user = (User) session.getAttribute("user");  
        //3、判断用户是否存在  
        if (user==null){  
            //4、不存在，拦截  
            response.setStatus(401);  
            return false;  
        }  
        //5、存在，保存到ThreadLocal  
        UserDTO userDTO=new UserDTO();  
        BeanUtils.copyProperties(user,userDTO);  
        UserHolder.saveUser(userDTO);  
        //6、放行  
        return true;  
    }  
  
    @Override  
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {  
        //移除用户  
        UserHolder.removeUser();  
    }  
}
```
	注册拦截器
```java
@Configuration  
public class MvcConfig implements WebMvcConfigurer {  
    //添加拦截器  
    public void addInterceptors(InterceptorRegistry registry) {  
        registry.addInterceptor(new LoginInterceptor())  
                .excludePathPatterns(  
                        "/shop/**",  
                        "/voucher/**",  
                        "/shop-type/**",  
                        "/upload/**",  
                        "/blog/hot",  
                        "/user/code",  
                        "/user/login"  
                );  
    }  
}
```
#### (5)Session模式和JWT令牌模式的差异
	Session
		服务端有“状态”，用户信息存储在服务器内存/Redis里，依赖 `JSESSIONID` 找到用户
		浏览器自动携带 Cookie（`JSESSIONID`），前端无需关心
		单服务器不需要额外处理，分布式/集群环境，Session需要共享（通过Redis）
		比较安全，SessionId 短小，用户数据不暴露；但要小心CSRF 攻击（因为浏览器会自动带 
		Cookie）
		服务端可以随时销毁 Session
	JWT
		服务端“无状态”，用户信息都在 **token 本身**（加密签名保证不被篡改），服务器不需要存储
		前端需要自己保存 token（`localStorage`、`sessionStorage` 或 Cookie），并在每次请
		求时手动放到 `Authorization` 请求头里
		天然适合分布式，因为服务端不用存储会话，只要能验证 token 就行
		数据在 token 里（通常是 base64 编码），虽然有签名防篡改，但**敏感信息不要放**（别人能
		解码看到内容）。而且 token 一旦泄漏，除非过期，否则无法强制失效
		验证只需要检查签名，性能更好，适合高并发
		一旦签发，除非过期，否则服务端无法单方面让它失效
	总结
		JWT：前端需要配合存取 token，适合分布式和微服务，性能好，但安全性和“主动失效”处理要注
			意
		Session：简单、安全，适合中小型应用，前端几乎无感知，但分布式需要额外处理
#### （6）Session共享
	作用：由于Session不共享，当发送和接收验证码的不是一个服务器，出现错误问题
	解决方案：将对应信息存放到Redis中，这样任何一台服务器都可以访问到存储的内容
	相关代码展示
	Service层
```java
@Service  
@Slf4j  
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {  
  
    @Autowired  
    private StringRedisTemplate redisTemplate;  
  
    /**  
     * 发送并保存验证码  
     * @param phone  
     * @param session  
     * @return  
     */  
    public Result sendCode(String phone, HttpSession session) {  
        //1、校验手机号  
        if (RegexUtils.isPhoneInvalid(phone)) {  
            //2、不符合，返回错误信息  
            return Result.fail("手机格式错误");  
        }  
        //3、符合，生成验证码  
        //使用随机生成器,生成长度为6位  
        String code = RandomUtil.randomNumbers(6);  
        //4、缓存到redis中  
        redisTemplate.opsForValue().set(RedisConstants.LOGIN_CODE_KEY + phone, code, RedisConstants.LOGIN_CODE_TTL, TimeUnit.MINUTES);  
//        session.setAttribute("code",code);  
        //TODO 5、发送验证码  
  
        log.debug("发送短信验证码成功，验证码：{}", code);  
        return Result.ok();  
    }  
  
    /**  
     * 登录功能实现  
     * @param loginForm  
     * @param session  
     * @return  
     */  
    public Result login(LoginFormDTO loginForm, HttpSession session) {  
        //1、校验手机号和验证码  
        if (RegexUtils.isPhoneInvalid(loginForm.getPhone())) {  
            //2、不符合，返回错误信息  
            return Result.fail("手机格式错误");  
        }  
        //3、根据手机号查询用户信息  
        String code = redisTemplate.opsForValue().get(RedisConstants.LOGIN_CODE_KEY+loginForm.getPhone());  
        //4、判断用户是否存在  
        if (code == null || !code.equals(loginForm.getCode())) {  
            return Result.fail("验证码有误");  
        }  
        //5、用户不存在，创建新用户并保存  
        User user = query().eq("phone", loginForm.getPhone()).one();  
        if (user == null) {  
            user = createUserWithPhone(loginForm.getPhone());  
        }  
        //6、保存用户信息到redis中  
        /*  
         *  （1）随机生成token，作为令牌  
         *  （2）将User对象转为Hash存储  
         *  （3）存储到redis中  
         */        String token = UUID.randomUUID().toString(true);  
        UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);  
        Map<String, Object> userMap = BeanUtil.beanToMap(userDTO, new HashMap<>(),  
                CopyOptions.create()  
                        .setIgnoreNullValue(true)  
                        .setFieldValueEditor((fieldName,fieldValue)->fieldValue.toString())  
                );  
        redisTemplate.opsForHash().putAll(RedisConstants.LOGIN_USER_KEY+token,userMap);  
        //有效期：1小时  
        redisTemplate.expire(RedisConstants.LOGIN_USER_KEY+token,RedisConstants.LOGIN_CODE_TTL,TimeUnit.HOURS);  
//      session.setAttribute("user", BeanUtil.copyProperties(user, UserDTO.class));  
  
        return Result.ok(token);  
    }  
  
    private User createUserWithPhone(String phone) {  
        //创建新用户  
        User user = new User();  
        user.setPhone(phone);  
        user.setNickName(SystemConstants.USER_NICK_NAME_PREFIX + RandomUtil.randomString(10));  
        //保存用户  
        save(user);  
        return user;  
    }  
}
```
	拦截器层 
	拦截器不仅将其中的Session用Redis进行替换，而且加了一层拦截器
	防止用户长时间逗留在不需要检验token的页面，因此，增加一层专门用来刷新token（若存在）
```java
//第一层拦截
public class RefreshTokenInterceptor implements HandlerInterceptor {  
    //由于不是经过Spring构建，因此无法直接创建  
    private StringRedisTemplate redisTemplate;  
  
    public RefreshTokenInterceptor(StringRedisTemplate redisTemplate) {  
        this.redisTemplate = redisTemplate;  
    }  
  
    @Override  
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  
        //1、获取请求头中的token  
        String token = request.getHeader("authorization");  
        if (StrUtil.isBlank(token)){  
            return true;   //没有token，没有刷新的必要，直接跳过该拦截器  
        }  
  
        //2、获取Redis中的用户  
        Map<Object, Object> userMap = redisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token);  
  
        //3、判断用户是否存在  
        if (userMap.isEmpty()){  
            return true;  //用户不存在，则该token没有刷新的必要  
        }  
        //4、将Map转换为User对象  
        //第三个参数表示转换有问题是否忽略  
        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(),false);  
        //5、存在，保存到ThreadLocal  
        UserHolder.saveUser(userDTO);  
  
        //6、刷新token有效期  
        redisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token,RedisConstants.LOGIN_CODE_TTL, TimeUnit.HOURS);  
        //7、放行  
        return true;  
    }  
  
    @Override  
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {  
        //移除用户  
        UserHolder.removeUser();  
    }  
}
```
	第二层拦截
```java
public class LoginInterceptor implements HandlerInterceptor {  
  
    @Override  
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  
        //如果UserHolder没有获取到User，说明不存在登录的用户，直接返回用户  
        if (UserHolder.getUser()==null){  
            response.setStatus(401);  
            return false;  
        }  
  
        return true;  
    }  
}
```

