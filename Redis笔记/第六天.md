---
date: 2025-08-26
aliases:
  - 黑马Redis[48-55]
tags:
  - 优惠卷秒杀
  - 全局唯一ID
  - Redis自增
  - 雪花算法
  - CountDownLatch
  - 超卖问题
  - 乐观锁
  - 悲观锁
  - 一人一单
---
# 优惠卷秒杀
---
### 全局唯一ID
#### （1）使用mysql自增ID带来的问题
	id的规律太明显，容易被用户察觉
	受到单表数量的限制，当规模较大，数据分表存储的时候，可能出现ID冲突的问题
#### （2）全局ID生成器
	在分布式系统下生成全局唯一ID的工具
	特性
		唯一性
		高可用
		高性能
		递增性
		安全性
#### （3）解决策略
	UUID
	Redis自增
	雪花算法
	数据库自增（专门维护一张ID表）
#### （4）Redis自增
![[Pasted image 20250826080702.png]]
	代码实现
```java
@Component  
public class RedisIdWorker {  
  
    //开始时间戳  
    private static final long BEGIN_TIMESTAMP = 1724630400L;  
    //序列号位数(定义成全局常量，方便以后得修改)  
    private static final int COUNT_BITS = 32;  
    @Autowired  
    private StringRedisTemplate redisTemplate;  
  
    public long nextId(String keyPrefix) {  
        //1、生成时间戳  
        long nowSecond = LocalDateTime.now().toEpochSecond(ZoneOffset.UTC);  
        long timestamp = nowSecond - BEGIN_TIMESTAMP;  
        //2、生成序列号  
        //2.1 获取当天的日期，精确到天  
        String date = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy:MM:dd"));  
        //2.2 自增长  
        long increment = redisTemplate.opsForValue().increment("icr:" + keyPrefix + ":" + date);  
        //3、拼接并返回
        //逻辑拼接，由于位移，timeStamp低位全为0，而拼接increment正好，
        //只要increment对应位不为0，则就是该位的数值，如果为0，则都为0，取或为0  
        return timestamp << COUNT_BITS | increment;  
    }  
}
```
	测试
```java
//线程池大小为500  
private ExecutorService es=Executors.newFixedThreadPool(500);  
  
@Test  
public void testIdWorker() throws InterruptedException {  
    //开启300个线程任务  
    //CountDownLatch：协调多个线程的执行顺序  
    CountDownLatch latch=new CountDownLatch(300);  
    //每次的线程任务  
    Runnable task=()->{  
        for (int i = 0; i < 10; i++) {  
            long id = redisIdWorker.nextId("order");  
            System.out.println("id = " + id);  
        }  
        //完成一个线程任务，latch减一  
        latch.countDown();  
    };  
  
    long begin = System.currentTimeMillis();  
    for (int i = 0; i < 300; i++) {  
        //提交300个线程任务到线程池  
        es.submit(task);  
    }  
    //一般放在主线程中，调用该方法的线程会被阻塞，知道countDown被减为0  
    latch.await();  
    long end=System.currentTimeMillis();  
    System.out.println("time:"+(end-begin));  
}
```
#### （5）CountDownLatch
	作用：让一组线程等待某个条件完成后再继续执行，或者让主线程等待子线程执行完
	常用方法
		countDown（）
			调用一次，计数器减 1
			一般放在 子线程执行结束 的地方
			当计数器减到 0 时，所有在 `await()` 上等待的线程都会被唤醒，继续执行
		await()
			调用该方法的线程会阻塞，直到计数器减到 0
			一般放在 主线程 或 需要等待的线程 中
### （6）雪花算法
	原理：基于时间戳 + 机器 ID + 序列号拼接生成 64 位长整型 ID
	优点
		分布式环境下仍能生成全局唯一 ID，不依赖数据库/Redis
		ID 大小固定（Long 类型），效率高，存储空间小
		按时间趋势递增，插入数据库时对索引比较友好
	缺点
		对服务器时间依赖强，如果**时钟回拨**需要特殊处理
		在跨语言、跨系统时要保证 **机器 ID 唯一**，否则可能冲突
	适用场景
		高并发分布式系统
		需要趋势递增 ID 的业务（如订单号、日志 ID、消息队列 ID）
		不想依赖中心化服务（数据库/Redis）
	代码实现
```java
public class SnowflakeIdWorker {  
    // ==============================Fields===========================================  
    /** 开始时间戳 (可自定义一个开始的纪元，比如 2020-01-01) */  
    private final long twepoch = 1756202509L; // 2020-01-01 00:00:00  
  
    /** 机器ID所占的位数 */  
    private final long workerIdBits = 5L;  
  
    /** 数据标识ID所占的位数 */  
    private final long datacenterIdBits = 5L;  
  
    /** 支持的最大机器id，结果是31 */  
    private final long maxWorkerId = -1L ^ (-1L << workerIdBits);  
  
    /** 支持的最大数据标识id，结果是31 */  
    private final long maxDatacenterId = -1L ^ (-1L << datacenterIdBits);  
  
    /** 序列在id中占的位数 */  
    private final long sequenceBits = 12L;  
  
    /** 机器ID向左移12位 */  
    private final long workerIdShift = sequenceBits;  
  
    /** 数据标识id向左移17位 (12+5) */  
    private final long datacenterIdShift = sequenceBits + workerIdBits;  
  
    /** 时间截向左移22位 (5+5+12) */  
    private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;  
  
    /** 生成序列的掩码，这里是4095 (0b111111111111=0xfff=4095) */  
    private final long sequenceMask = -1L ^ (-1L << sequenceBits);  
  
    /** 工作机器ID(0~31) */  
    private long workerId;  
  
    /** 数据中心ID(0~31) */  
    private long datacenterId;  
  
    /** 毫秒内序列(0~4095) */  
    private long sequence = 0L;  
  
    /** 上次生成ID的时间截 */  
    //由于第一次没有值，所以初值设置为-1L  
    private long lastTimestamp = -1L;  
  
    //==============================Constructors=====================================  
    /**  
     * 构造函数  
     * @param workerId 工作ID (0~31)  
     * @param datacenterId 数据中心ID (0~31)  
     */    public SnowflakeIdWorker(long workerId, long datacenterId) {  
        if (workerId > maxWorkerId || workerId < 0) {  
            throw new IllegalArgumentException(String.format("worker Id can't be greater than %d or less than 0", maxWorkerId));  
        }  
        if (datacenterId > maxDatacenterId || datacenterId < 0) {  
            throw new IllegalArgumentException(String.format("datacenter Id can't be greater than %d or less than 0", maxDatacenterId));  
        }  
        this.workerId = workerId;  
        this.datacenterId = datacenterId;  
    }  
  
    // ==============================Methods==========================================  
    /**  
     * 获得下一个ID (线程安全的)  
     * @return SnowflakeId  
     */    public synchronized long nextId() {  
        long timestamp = timeGen();  
  
        // 如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过  
        if (timestamp < lastTimestamp) {  
            throw new RuntimeException(  
                    String.format("Clock moved backwards. Refusing to generate id for %d milliseconds", lastTimestamp - timestamp));  
        }  
  
        // 如果是同一时间生成的，则进行毫秒内序列  
        if (lastTimestamp == timestamp) {  
            sequence = (sequence + 1) & sequenceMask;  
            // 毫秒内序列溢出  
            if (sequence == 0) {  
                // 阻塞到下一个毫秒，获得新的时间戳  
                timestamp = tilNextMillis(lastTimestamp);  
            }  
        }  
        // 时间戳改变，毫秒内序列重置  
        else {  
            sequence = 0L;  
        }  
  
        // 上次生成ID的时间截  
        // 赋值给lastTimestamp，当做下一次时间戳的上一个时间戳  
        lastTimestamp = timestamp;  
  
        // 移位并通过或运算拼到一起组成64位的ID  
        return ((timestamp - twepoch) << timestampLeftShift) //  
                | (datacenterId << datacenterIdShift) //  
                | (workerId << workerIdShift) //  
                | sequence;  
    }  
  
    /**  
     * 阻塞到下一个毫秒，直到获得新的时间戳  
     * @param lastTimestamp 上次生成ID的时间截  
     * @return 当前时间戳  
     */  
    protected long tilNextMillis(long lastTimestamp) {  
        long timestamp = timeGen();  
        while (timestamp <= lastTimestamp) {  
            timestamp = timeGen();  
        }  
        return timestamp;  
    }  
  
    /**  
     * 返回以毫秒为单位的当前时间  
     */  
    protected long timeGen() {  
        return System.currentTimeMillis();  
    }  
}
```

### 实现优惠卷秒杀下单
---
#### （1）添加秒杀券
	使用MyBatis plus即可
```java
/**  
 * 新增普通券  
 * @param voucher 优惠券信息  
 * @return 优惠券id  
 */@PostMapping  
public Result addVoucher(@RequestBody Voucher voucher) {  
    voucherService.save(voucher);  
    return Result.ok(voucher.getId());  
}
```
#### （2）实现秒杀券下单
	Controller层
```java
/**  
 * 新增秒杀券  
 * @param voucher 优惠券信息，包含秒杀信息  
 * @return 优惠券id  
 */@PostMapping("seckill")  
public Result addSeckillVoucher(@RequestBody Voucher voucher) {  
    voucherService.addSeckillVoucher(voucher);  
    return Result.ok(voucher.getId());  
}
```
	Service层
```java
@Service  
public class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements IVoucherOrderService {  
  
    @Autowired  
    private ISeckillVoucherService seckillVoucherService;  
  
    private final SnowflakeIdWorker snowflakeIdWorker=new SnowflakeIdWorker(29,20);  
  
    @Autowired  
    private RedisIdWorker redisIdWorker;  
    /**  
     * 下单秒杀券  
     * @param voucherId  
     * @return  
     */  
    @Transactional  
    public Result secKillVoucher(Long voucherId) {  
        //1、查询优惠券信息  
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);  
        //2、判断是否在秒杀期间  
        if(voucher.getBeginTime().isAfter(LocalDateTime.now())||voucher.getEndTime().isBefore(LocalDateTime.now())){  
            return Result.fail("不在秒杀时间范围内");  
        }  
        //3、判断库存是否充足  
        if(voucher.getStock()<1){  
            return Result.fail("库存不足");  
        }  
        //4、扣减库存  
        boolean success = seckillVoucherService.update()  
                .setSql("stock=stock-1")  
                .eq("voucher_id", voucherId)  
                .update();  
        if(!success){  
            return Result.fail("库存不足");  
        }  
        //5、创建订单  
        VoucherOrder voucherOrder = new VoucherOrder();  
        //订单id  
        long orderId = redisIdWorker.nextId("order");  
        voucherOrder.setId(orderId);  
        //用户id  
        voucherOrder.setUserId(UserHolder.getUser().getId());  
        //代金券id  
        voucherOrder.setVoucherId(voucherId);  
        save(voucherOrder);  
        //6、返回订单id  
        return Result.ok(orderId);  
    }  
}
```
### 超卖问题
---
#### （1）定义
	高并发场景下，可能存在超出数量限制的购买
#### （2）锁的种类
	悲观锁
		认为线程安全问题一定会发生，因此，操作数据之前会先获取锁，确保线程的执行
		Synchronized、Lock都属于悲观锁
		性能一般
	乐观锁
		认为线程安全不一定会发生，只在更新数据的时判断是否线程安全问题，如果发生，则重试或异常
		处理不好，成功率降低
#### （3）乐观锁方法
	1、版本号法：添加一个版本号，在进行修改的时候，判断版本号是否出现了修改，没有则更新数据，版本
				号加一，如果不一致，则修改无效
	2、CAS法：将要更新的数据作为版本号，修改前先比较是否和获取的时候数值一致，如果一致，则进行修
				该，不一致，则修改无效
#### （4）超卖问题的解决（乐观锁）
```java
@Service  
public class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements IVoucherOrderService {  
  
    @Autowired  
    private ISeckillVoucherService seckillVoucherService;  
  
    private final SnowflakeIdWorker snowflakeIdWorker=new SnowflakeIdWorker(29,20);  
  
    @Autowired  
    private RedisIdWorker redisIdWorker;  
    /**  
     * 下单秒杀券  
     * @param voucherId  
     * @return  
     */  
    @Transactional  
    public Result secKillVoucher(Long voucherId) {  
        //1、查询优惠券信息  
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);  
        //2、判断是否在秒杀期间  
        if(voucher.getBeginTime().isAfter(LocalDateTime.now())||voucher.getEndTime().isBefore(LocalDateTime.now())){  
            return Result.fail("不在秒杀时间范围内");  
        }  
        //3、判断库存是否充足  
        if(voucher.getStock()<1){  
            return Result.fail("库存不足");  
        }  
        //4、扣减库存  
        boolean success = seckillVoucherService.update()  
                .setSql("stock=stock-1")  
                .eq("voucher_id", voucherId)  
                .gt("stock",0)  //乐观锁：CAS法  
                .update();  
        if(!success){  
            return Result.fail("库存不足");  
        }  
        //5、创建订单  
        VoucherOrder voucherOrder = new VoucherOrder();  
        //订单id  
        long orderId = redisIdWorker.nextId("order");  
        voucherOrder.setId(orderId);  
        //用户id  
        voucherOrder.setUserId(UserHolder.getUser().getId());  
        //代金券id  
        voucherOrder.setVoucherId(voucherId);  
        save(voucherOrder);  
        //6、返回订单id  
        return Result.ok(orderId);  
    }  
}
```

### ==实现一人一单==
---
#### 代码实现
	Service层
```java
@Service  
public class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements IVoucherOrderService {  
  
    @Autowired  
    private ISeckillVoucherService seckillVoucherService;  
  
    private final SnowflakeIdWorker snowflakeIdWorker=new SnowflakeIdWorker(29,20);  
  
    @Autowired  
    private RedisIdWorker redisIdWorker;  
    /**  
     * 下单秒杀券  
     * @param voucherId  
     * @return  
     */  
    public Result secKillVoucher(Long voucherId) {  
        //1、查询优惠券信息  
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);  
        //2、判断是否在秒杀期间  
        if(voucher.getBeginTime().isAfter(LocalDateTime.now())||voucher.getEndTime().isBefore(LocalDateTime.now())){  
            return Result.fail("不在秒杀时间范围内");  
        }  
        //3、判断库存是否充足  
        if(voucher.getStock()<1){  
            return Result.fail("库存不足");  
        }  
  
        Long userId = UserHolder.getUser().getId();  
        synchronized (userId.toString().intern()) {  
            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();  
            return proxy.createVoucherOrder(voucherId,userId);  
        }  
    }  
  
    @Transactional  
    public Result createVoucherOrder(Long voucherId,Long userId) {  
        //4、一人一单  
        //4.1 查询订单  
        int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();  
        //4.2 判断是否存在  
        if(count>0){  
            //不能够重复购买  
            return Result.fail("不能重复购买");  
        }  
        //5、扣减库存  
        boolean success = seckillVoucherService.update()  
                .setSql("stock=stock-1")  
                .eq("voucher_id", voucherId)  
                .gt("stock",0)  //乐观锁：CAS法  
                .update();  
        if(!success){  
            return Result.fail("库存不足");  
        }  
        //6、创建订单  
        VoucherOrder voucherOrder = new VoucherOrder();  
        //订单id  
        long orderId = redisIdWorker.nextId("order");  
        voucherOrder.setId(orderId);  
        //用户id  
        voucherOrder.setUserId(userId);  
        //代金券id  
        voucherOrder.setVoucherId(voucherId);  
        save(voucherOrder);  
        //6、返回订单id  
        return Result.ok(orderId);  
    }  
}
```
	启动类（调整动态代理模式）
```java
@EnableAspectJAutoProxy(exposeProxy = true)  //调整动态代理模式  
@MapperScan("com.hmdp.mapper")  
@SpringBootApplication  
public class HmDianPingApplication {  
  
    public static void main(String[] args) {  
        SpringApplication.run(HmDianPingApplication.class, args);  
    }  
  
}
```
	相关的maven坐标
```xml
<dependency>  
    <groupId>org.aspectj</groupId>  
    <artifactId>aspectjweaver</artifactId>  
</dependency>
```
### 动态代理的失效---调用自己方法绕过动态代理
	出现的情况：
		从上边的代码可以看出，createVoucherOrder添加了@Transactional，而Spring的事务管理
		通过AOP动态代理实现。
	简单来说
		当你调用一个带 `@Transactional` 注解的方法时，实际上是 **代理对象** 在拦截方法调用，
		给你加上了事务的逻辑（比如事务开启、提交、回滚）
	this带来的问题
		如果默认直接调用类中的方法，则是普通java方法调用，不会经过Spring代理对象
		导致事务@Transactional不会生效
	解决方案
		AopContext.currentProxy()
		获取当前类的 **AOP 代理对象**，然后通过代理对象去调用 `createVoucherOrder` 方法
		这样才能触发 **Spring AOP 的事务增强逻辑**，事务才会生效。

