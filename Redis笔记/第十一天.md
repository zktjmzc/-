---
date: 2025-09-02
aliases:
  - 黑马Redis
tags:
  - 滚动分页查询
  - GEO
  - BitMap
  - Hyperloglog
cssclasses:
  -  滚动分页查询收件箱
  - 附近商户
  - 用户签到
  - 连续签到天数
  - UV统计
  - PV统计
---
# 滚动分页查询收件箱
---
	采用原因：
			如果按照传统的使用角标进行查询，则当数据发生更新的时候，数据的相对位置会发生改变，假设一页10条数据，你翻页的一瞬间，更新十条数据，此时你翻到的页的内容与原来页的内容一致，影响用户体验
	原理：
		赋予每个数据一个根据时间戳得到的数值，每次记录当前页的最后一条数据的值，下次翻页，得到的就是其后面的10条数据
### 代码展示
	Controller层
```java
/**  
 * 查询关注这发送的信息（推送）  
 * @param max  
 * @param offset  
 * @return  
 */  
@GetMapping("/of/follow")  
public Result queryBlogOfFollow(  
        @RequestParam("lastId")Long max, @RequestParam(value = "offset",defaultValue = "0")Integer offset){  
    return blogService.queryBlogOfFollow(max,offset);  
}
```
	Service层
```java
/**  
 * 基于滚动分页查询收件箱  
 * @param max  
 * @param offset  
 * @return  
 */  
public Result queryBlogOfFollow(Long max, Integer offset) {  
    //1、获取当前用户id  
    Long userId = UserHolder.getUser().getId();  
    //2、查询收件箱  
    String key= RedisConstants.FEED_KEY+userId;  
    Set<ZSetOperations.TypedTuple<String>> typedTuples = redisTemplate.opsForZSet()  
            .reverseRangeByScoreWithScores(key, 0, max, offset, 2);  
    //3、非空判断  
    if(typedTuples==null||typedTuples.isEmpty()){  
        return Result.ok();  
    }  
    //4、解析数据：blogId、minTime、offset  
    List<Long>ids=new ArrayList<>(typedTuples.size());   //收集当前页所要用到的笔记id  
    long minTime=0;  
    int os=1;  
    for (ZSetOperations.TypedTuple<String> typedTuple : typedTuples) {  
        ids.add(Long.valueOf(typedTuple.getValue()));  
        long time = typedTuple.getScore().longValue();  
        if(time==minTime){  
            os++;  
        }else {  
            minTime=time;  
            os=1;  
        }  
    }  
    //5、根据id查询blog  
    String join = StrUtil.join(",", ids);  
    List<Blog> blogs = query()  
            .in("id",ids)  
            .last("ORDER BY FIELD(id,"+join+")")  
            .list();  
    for (Blog blog : blogs) {  
        //5.1、查询相关的用户  
        queryBlogUser(blog);  
        //5.2、查询blog是否被点赞  
        isBlogLiked(blog);  
    }  
  
    //6、封装并返回  
    ScoreResult scoreResult = new ScoreResult();  
    scoreResult.setList(blogs);  
    scoreResult.setMinTime(minTime);  
    scoreResult.setOffset(os);  
  
    return Result.ok(scoreResult);  
}
```
# 附近商户
---
### 1、GEO数据结构
![[Pasted image 20250902090359.png]]
	GEOSEARCH用法
		语法：
```bash
GEOSEARCH key 
  FROMMEMBER member | FROMLONLAT longitude latitude
  BYRADIUS radius m|km|ft|mi | BYBOX width height m|km|ft|mi
  [ASC|DESC]
  [COUNT count [ANY]]
  [WITHCOORD]
  [WITHDIST]
  [WITHHASH]
  
```
	- **key**：存储地理位置数据的有序集合（通过 `GEOADD` 添加的）。
    
- **FROMMEMBER member**：从已存储的某个地点作为圆心开始搜索。
    
- **FROMLONLAT lon lat**：从指定的经纬度作为圆心开始搜索。
    
- **BYRADIUS radius unit**：指定半径范围（支持 m 米，km 千米，ft 英尺，mi 英里）。
    
- **BYBOX width height unit**：以矩形范围搜索。
    
- **ASC|DESC**：按距离排序（近到远 / 远到近）。
    
- **COUNT count [ANY]**：限制返回的数量。 
    
- **WITHCOORD**：返回坐标。
    
- **WITHDIST**：返回距离。
    
- **WITHHASH**：返回 geohash 值。
### 2、功能实现
	Controller层
```java
    /**  
     * 根据商铺类型分页查询商铺信息  
     * @param typeId 商铺类型  
     * @param current 页码  
     * @return 商铺列表  
     */  
    @GetMapping("/of/type")  
    public Result queryShopByType(  
            @RequestParam("typeId") Integer typeId,  
            @RequestParam(value = "current", defaultValue = "1") Integer current,  
            @RequestParam(value = "x",required = false)Double x,  
            @RequestParam(value = "y",required = false)Double y  
    ) {  
//        // 根据类型分页查询  
//        Page<Shop> page = shopService.query()  
//                .eq("type_id", typeId)  
//                .page(new Page<>(current, SystemConstants.DEFAULT_PAGE_SIZE));  
//        // 返回数据  
//        return Result.ok(page.getRecords());  
        return shopService.queryShopByType(typeId,current,x,y);  
    }
```
	Service层
```java
/**  
 * 分类分页查询店铺信息  
 * @param typeId  
 * @param current  
 * @param x  
 * @param y  
 * @return  
 */  
public Result queryShopByType(Integer typeId, Integer current, Double x, Double y) {  
    //1、是否需要根据坐标查询  
    if(x==null||y==null){  
        //不需要坐标查询，按数据库查询  
    Page<Shop> page = query()  
            .eq("type_id", typeId)  
            .page(new Page<>(current, SystemConstants.DEFAULT_PAGE_SIZE));  
    // 返回数据  
    return Result.ok(page.getRecords());  
    }  
    //2、计算分页参数  
    int from=(current-1)*SystemConstants.DEFAULT_PAGE_SIZE;  
    int end=current*SystemConstants.DEFAULT_PAGE_SIZE;  
    //3、查询redis、按距离排序、分页  
    String key = RedisConstants.SHOP_GEO_KEY + typeId;  
    GeoResults<RedisGeoCommands.GeoLocation<String>> results = redisTemplate.opsForGeo()  
            .search(key,  
                    GeoReference.fromCoordinate(x, y),  
                    new Distance(5, Metrics.KILOMETERS),  
                    RedisGeoCommands.GeoSearchCommandArgs  
                            .newGeoSearchArgs()  //创建一个对象，表名要获取的东西，例如距离，坐标等  
                            .includeDistance().limit(end)  //获取距离  
            );  
    //4、解析出id  
    if(results==null){  
        return Result.ok(Collections.emptyList());  
    }  
    //获取信息实体  
    List<GeoResult<RedisGeoCommands.GeoLocation<String>>> list = results.getContent();  
    if(list.size()<=from){  
        //没有下一页  
        return Result.ok(Collections.emptyList());  
    }  
    //4.1 截取from-end的部分  
    List<Long>ids=new ArrayList<>(list.size());  
    Map<String,Distance>distanceMap=new HashMap<>(list.size());  
    list.stream().skip(from).forEach(result->{  
        //获取店铺id  
        String shopIdStr = result.getContent().getName();  
        ids.add(Long.valueOf(shopIdStr));  
        //获取距离  
        Distance distance = result.getDistance();  
        distanceMap.put(shopIdStr,distance);  
    });  
    //5、根据id查询shop  
    String join = StrUtil.join(",", ids);  
    List<Shop> shops = query().in("id", ids)  
            .last("ORDER BY FIELD(id," + join + ")")  //保障有序性  
            .list();  
    //获取对应店铺的距离  
    for (Shop shop : shops) {  
        shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());  
    }  
    //6、返回  
    return Result.ok(shops);  
}
```
### 用户签到
---
### 1、BitMap（位图）
	功能实现：按月统计用户签到信息，签到为1，未签为0；每一个bit位代表一天，称为“位图”
	用法

![[Pasted image 20250902122311.png]]
### 2、签到功能实现
	Controller层
```java
/**  
 * 签到功能实现  
 * @return  
 */  
@PostMapping("/sign")  
public Result sign(){  
    return userService.sign();  
}
```
	Service层

```java
/**  
 * 签到功能  
 * @return  
 */  
public Result sign() {  
    //1、获取当前登录的用户id  
    Long userId = UserHolder.getUser().getId();  
    //2、获取日期  
    LocalDateTime time = LocalDateTime.now();  
    //3、拼接key  
    String key = RedisConstants.USER_SIGN_KEY  
            +userId  
            +":"  
            + time.format(DateTimeFormatter.ofPattern("yyyyMM"));  
    //4、获取今天是本月的第几天  
    int dayOfMonth = time.getDayOfMonth();  
    //5、写入Redis  
    //SETBIT key offset 1    redisTemplate.opsForValue().setBit(key,dayOfMonth-1,true);  
    return Result.ok();  
}
```
### 3、签到统计
	Controller层
```java
/**  
 * 统计连续签到天数  
 * @return  
 */  
@GetMapping("sign/count")  
public Result signCount(){  
    return userService.signCount();  
}
```
	Service层
```java
/**  
 * 截止当前时间，本月连续签到的天数  
 * @return  
 */  
public Result signCount() {  
    //1、获取当前登录的用户id  
    Long userId = UserHolder.getUser().getId();  
    //2、获取日期  
    LocalDateTime time = LocalDateTime.now();  
    //3、拼接key  
    String key = RedisConstants.USER_SIGN_KEY  
            +userId  
            +":"  
            + time.format(DateTimeFormatter.ofPattern("yyyyMM"));  
    //4、获取今天是本月的第几天  
    int dayOfMonth = time.getDayOfMonth();  
    //5、获取本月截止目前为止的签到记录  
    List<Long> result = redisTemplate.opsForValue().bitField(  
            key,  
            BitFieldSubCommands.create()  
                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth))  
                    .valueAt(0)  
    );  
    if(result==null||result.isEmpty()){  
        return Result.ok(0);  
    }  
    Long num = result.get(0);  
    if(num==null||num==0){  
        return Result.ok(0);  
    }  
    //6、循环遍历  
    int count=0;  
    while (true) {  
        // 6.1 让获得的数据与1做与运算，得到数字的最后一个bit位  
        if((num & 1)==0){  
            //6.2 如果最后一位为0，则直接结束  
            break;  
        }else {  
            count++;  
        }  
        //7、不为0，计数器加1  
        num>>>=1;  
    }  
    return Result.ok(count);  
}
```
## UV统计
---
	1、定义：UV，全称“独立访客量”，一个用户一天内访问网站记为1次
			PV，全称“点击量”，用户每访问一次记为1次PV，衡量网站的流量
### 2、Hyperloglog
	定义：
		是loglog算法的派生的概率算法，用于确定非常大的集合的基数。
		Redis中，HLL是基于String结构实现的，单个HLL的内存大小永远小于16kb，代价是有小于0.81%
		的误差，对于UV统计是可以接受的。
		注意：Redis中，HLL所有添加的数值都只会记录一次

![[Pasted image 20250902142428.png]]
		实例演示

![[Pasted image 20250902142523.png]]
