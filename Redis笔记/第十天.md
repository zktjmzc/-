---
date: 2025-09-01
aliases:
  - 黑马Redis[77-85]
tags:
  - feed流
  - Timeline模式
  - 拉、推、推拉模式
cssclasses:
  - 达人探店
  - 点赞
  - 点赞排行
  - 共同关注
  - 共同推送
---
# 达人探店
---
### 1、查询笔记
	Service层
```java
/**  
 * 查询探点笔记  
 * @param id  
 * @return  
 */  
public Result queryBlogById(Long id) {  
    //1、查询blog  
    Blog blog = getById(id);  
    if(blog==null){  
        return Result.fail("笔记不存在");  
    }  
    //2、查询相关的用户  
    queryBlogUser(blog);  
    return Result.ok(blog);  
}

private void queryBlogUser(Blog blog) {  
    Long userId = blog.getUserId();  
    User user = userService.getById(userId);  
    blog.setName(user.getNickName());  
    blog.setIcon(user.getIcon());  
}
```
### 2、点赞
	Service层
```java
@Service  
public class BlogServiceImpl extends ServiceImpl<BlogMapper, Blog> implements IBlogService {  
  
    @Resource  
    private IBlogService blogService;  
    @Resource  
    private IUserService userService;  
    @Autowired  
    private StringRedisTemplate redisTemplate;  
  
    /**  
     * 查询探点笔记  
     * @param id  
     * @return  
     */  
    public Result queryBlogById(Long id) {  
        //1、查询blog  
        Blog blog = getById(id);  
        if(blog==null){  
            return Result.fail("笔记不存在");  
        }  
        //2、查询相关的用户  
        queryBlogUser(blog);  
        //3、查询blog是否被点赞  
        isBlogLiked(blog);  
        return Result.ok(blog);  
    }  
  
    private void isBlogLiked(Blog blog) {  
        //1、获取登录用户  
        Long userId = UserHolder.getUser().getId();  
        //2、判断用户是否已经点赞  
        String key="blog:liked:" +blog.getId();  
        Boolean isMember = redisTemplate.opsForSet().isMember(key, userId.toString());  
        blog.setIsLike(BooleanUtil.isTrue(isMember));  
    }  
  
    /**  
     * 查询热门评论  
     * @param current  
     * @return  
     */  
    @Override  
    public Result queryHotBy(Integer current) {  
        // 根据用户查询  
        Page<Blog> page = query()  
                .orderByDesc("liked")  
                .page(new Page<>(current, SystemConstants.MAX_PAGE_SIZE));  
        // 获取当前页数据  
        List<Blog> records = page.getRecords();  
        // 查询用户  
        records.forEach(blog -> {  
            this.queryBlogUser(blog);  
            this.isBlogLiked(blog);  
        });  
        return Result.ok(records);  
    }  
  
    /**  
     * 点赞  
     * @param id  
     * @return  
     */  
    public Result likeBlog(Long id) {  
        //1、获取登录用户  
        Long userId = UserHolder.getUser().getId();  
        //2、判断用户是否已经点赞  
        String key="blog:liked:"+id;  
        Boolean isMember = redisTemplate.opsForSet().isMember(key, userId.toString());  
        //3、如果未点赞，可以点赞  
        if(BooleanUtil.isFalse(isMember)){  
            //3.1 修改数据库  
            boolean isSuccess = update().setSql("liked=liked+1").eq("id", id).update();  
            if(isSuccess){  
                //3.2 保存用户到Redis中  
                redisTemplate.opsForSet().add(key,userId.toString());  
            }  
        }else {  
            //4、已经点赞，则取消点赞  
            boolean isSuccess = update().setSql("liked=liked-1").eq("id", id).update();  
            if(isSuccess){  
                //3.2 保存用户到Redis中  
                redisTemplate.opsForSet().remove(key,userId.toString());  
            }  
        }  
  
        return Result.ok();  
    }  
  
    private void queryBlogUser(Blog blog) {  
        Long userId = blog.getUserId();  
        User user = userService.getById(userId);  
        blog.setName(user.getNickName());  
        blog.setIcon(user.getIcon());  
    }  
}
```
### 3、点赞排行榜
```java
/**  
 * 点赞排行榜  
 * @param id  
 * @return  
 */  
public Result queryBlogLikes(Long id) {  
    String key = "blog:liked:" + id;  
    //1、查询点赞量Top5的用户 zrange key 0 4    Set<String> set = redisTemplate.opsForZSet().range(key, 0, 4);  
    if(set==null||set.isEmpty()){  
        return Result.ok(Collections.emptyList());  
    }  
    //2、析出其中的用户id  
    List<Long> ids = set.stream().map(Long::valueOf).collect(Collectors.toList());  
    String join = StrUtil.join(",", ids);  
    //3、根据用户id查询用户  
    List<UserDTO> userDTOS = userService.query().in("id",ids)  
            .last("ORDER BY FIELD (id,"+join+")").list()  
            .stream()  
            .map(user -> BeanUtil.copyProperties(user, UserDTO.class))  
            .collect(Collectors.toList());  
    //4、返回  
    return Result.ok(userDTOS);  
}
```
## 好友关注
---
### 1、关注和取关
	Controller层
```java
@RestController  
@RequestMapping("/follow")  
public class FollowController {  
    @Autowired  
    private IFollowService followService;  
  
    /**  
     * 关注或取关  
     * @param followUserId  
     * @param isFollow  
     * @return  
     */  
    @PutMapping("/{id}/{isFollow}")  
    public Result follow(@PathVariable("id")Long followUserId,@PathVariable("isFollow")Boolean isFollow){  
        return followService.follow(followUserId,isFollow);  
    }  
  
    /**  
     * 是否关注  
     * @param followUserId  
     * @return  
     */  
    @GetMapping("/or/not/{id}")  
    public Result isFollow(@PathVariable("id")Long followUserId){  
        return followService.isFollow(followUserId);  
    }  
}
```
	Service层
```java
@Service  
public class FollowServiceImpl extends ServiceImpl<FollowMapper, Follow> implements IFollowService {  
  
    /**  
     * 关注或取关  
     * @param followUserId  
     * @param isFollow  
     * @return  
     */  
    public Result follow(Long followUserId, Boolean isFollow) {  
        Long userId = UserHolder.getUser().getId();  
        //1、判断是关注还是取关  
        if(isFollow){  
            //2、关注，新增数据  
            Follow follow = new Follow();  
            follow.setUserId(userId);  
            follow.setFollowUserId(followUserId);  
            save(follow);  
        }else {  
            //3、取关，删除数据  
            remove(new QueryWrapper<Follow>().eq("user_id",userId).eq("follow_user_id",followUserId));  
        }  
        return Result.ok();  
    }  
  
    /**  
     * 是否关注  
     * @param followUserId  
     * @return  
     */  
    public Result isFollow(Long followUserId) {  
        Long userId = UserHolder.getUser().getId();  
        Integer count = query().eq("user_id", userId).eq("follow_user_id", followUserId).count();  
        return Result.ok(count>0);  
    }  
}
```
### 2、共同关注
	Controller层
```java
/**  
 * 共同关注  
 * @param id  
 * @return  
 */  
@GetMapping("/common/{id}")  
public Result followCommons(@PathVariable Long id){  
    return followService.followCommons(id);  
}
```
	Service层
```java
/**  
 * 共同关注  
 * @param id  
 * @return  
 */  
public Result followCommons(Long id) {  
    //1、获取当前用户  
    Long userId = UserHolder.getUser().getId();  
    String key1="follows:"+userId;  
    //2、求交集  
    String key2="follows:"+id;  
    Set<String> intersect = redisTemplate.opsForSet().intersect(key1, key2);  
    if(intersect==null||intersect.isEmpty()){  
        return Result.ok(Collections.emptyList());  
    }  
    //解析id  
    List<Long> ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());  
    //查询用户  
    List<UserDTO> list = userService.listByIds(ids).stream()  
            .map(user -> BeanUtil.copyProperties(user, UserDTO.class))  
            .collect(Collectors.toList());  
  
    return Result.ok(list);  
}
```
## 共同推送
---
### 1、feed流
	定义：为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息
	实现方式：
		（1）Timeline：不做内容筛选，按照时间排序，常用于好友和关注。
		（2）智能排序：利用智能算法规避违规、用户不感兴趣的信息。
### 2、Timeline模式
	拉模式：每个up的动态都会存在指定的空间内，当关注他的人去看消息的时候再从其中取，并按时间排序
			节省内存，但是耗时
	推模式：当up更新的时候，会将消息推送给每一个粉丝
			耗时短，内存消耗大
	推拉结合：
			人气不高的up，采用推模式
			人气高的up，如果是活跃粉丝，则采用推模式，普通粉丝采用拉模式
### 3、基于推模式实现关注推送功能
	（1）推送给粉丝
	Controller层
```java
@PostMapping  
public Result saveBlog(@RequestBody Blog blog) {  
    return blogService.saveBlog(blog);  
}
```
	Service层
```java
/**  
 * 创建笔记，并推送给粉丝  
 * @param blog  
 * @return  
 */  
public Result saveBlog(Blog blog) {  
    //1、获取登录用户  
    Long userId = UserHolder.getUser().getId();  
    blog.setUserId(userId);  
    //2、保存探点笔记  
    boolean isSuccess = save(blog);  
    if(isSuccess){  
        return Result.fail("新增笔记失败");  
    }  
    //3、查询笔记作者的所有粉丝  
    List<Follow> fans= followService.query().eq("follow_user_id", userId).list();  
    //4、推送笔记id给粉丝  
    for (Follow fan : fans) {  
        //4.1 获取粉丝id  
        Long fanUserId = fan.getUserId();  
        //4.2 推送  
        String key="feed:"+fanUserId;  
        redisTemplate.opsForZSet().add(key,blog.getId().toString(),System.currentTimeMillis());  
    }  
    //5、返回id  
    return Result.ok(blog.getId());  
}
```
