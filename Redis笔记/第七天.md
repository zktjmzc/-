---
date: 2025-08-27
aliases:
  - 黑马Redis[55-65]
tags:
  - 分布式锁
  - Lua脚本
  - Redisson
  - 可重入锁原理
  - singletonList方法---单参数创建List
  - execute（）---在Redis中操作Lua脚本
---
# 分布式锁
---
### 1、使用原因
	当服务器采用集群模式，高并发运行的时候，由于负载均衡的原因，一个账号发出的多次请求可能分给不
	不同的服务器，此时锁可能会失效，因为不同服务器的锁监视器不同，此时一人一单的功能会出现问题
### 2、定义
	在分布式或者集群模式下，多进程可见并其互斥的锁
	多进程可见：保障锁的有效性
	互斥：保障锁的功能性
### 3、实现
![[Pasted image 20250827095549.png]]
### 4、代码实现（初级版本）
	Utils
```java
public class SimpleRedisLock implements ILock{  
  
    private String name;  
    private StringRedisTemplate redisTemplate;  
    private String prefixKey=RedisConstants.KEY_PREFIX;  
  
    public SimpleRedisLock(String name, StringRedisTemplate redisTemplate) {  
        this.name = name;  
        this.redisTemplate = redisTemplate;  
    }  
  
    /**  
     * 尝试获取锁  
     * @param timeoutSec  锁持有的超时时间，过期后自动释放  
     * @return false获取失败，true获取成功  
     */  
    public boolean tryLock(long timeoutSec) {  
        //获取当前线程标识  
        long id = Thread.currentThread().getId();  
        // 获取锁  
        Boolean success = redisTemplate.opsForValue().setIfAbsent(prefixKey + name, id + "", timeoutSec, TimeUnit.SECONDS);  
        return Boolean.TRUE.equals(success);  
    }  
  
    /**  
     * 释放锁  
     */  
    public void unlock() {  
        redisTemplate.delete(prefixKey + name);  
    }  
}
```
	Service
```java
/**  
 * 下单秒杀券  
 * @param voucherId  
 * @return  
 */  
public Result secKillVoucher(Long voucherId) {  
    //1、查询优惠券信息  
    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);  
    //2、判断是否在秒杀期间  
    if(voucher.getBeginTime().isAfter(LocalDateTime.now())||voucher.getEndTime().isBefore(LocalDateTime.now())){  
        return Result.fail("不在秒杀时间范围内");  
    }  
    //3、判断库存是否充足  
    if(voucher.getStock()<1){  
        return Result.fail("库存不足");  
    }  
  
    Long userId = UserHolder.getUser().getId();  
    //创建锁对象  
    SimpleRedisLock redisLock = new SimpleRedisLock("order:" + userId, redisTemplate);  
    //获取锁  
    boolean isLock = redisLock.tryLock(1200);  
    //判断是否获取锁成功  
    if(!isLock){  
        //获取锁失败，返回错误信息或重试  
        return Result.fail("一人一单");  
    }  
    try {  
        IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();  
        return proxy.createVoucherOrder(voucherId,userId);  
    } finally {  
        redisLock.unlock();  //一定要释放锁  
    }  
}
```
### 5、简单实现，产生的问题
![[Pasted image 20250827104635.png]]
	解决方案 ：释放锁时判断是否是当前线程
	代码展示
```java
public class SimpleRedisLock implements ILock {  
  
    private String name;  
    private StringRedisTemplate redisTemplate;  
    private final String prefixKey = RedisConstants.KEY_PREFIX;  
    private final String ID_PREFIX = UUID.randomUUID().toString(true) + "-";  
  
    public SimpleRedisLock(String name, StringRedisTemplate redisTemplate) {  
        this.name = name;  
        this.redisTemplate = redisTemplate;  
    }  
  
    /**  
     * 尝试获取锁  
     * @param timeoutSec  锁持有的超时时间，过期后自动释放  
     * @return false获取失败，true获取成功  
     */  
    public boolean tryLock(long timeoutSec) {  
        //获取当前线程标识  
        String id = ID_PREFIX+Thread.currentThread().getId();  
        // 获取锁  
        Boolean success = redisTemplate.opsForValue().setIfAbsent(prefixKey + name, id, timeoutSec, TimeUnit.SECONDS);  
        return Boolean.TRUE.equals(success);  
    }  
  
    /**  
     * 释放锁  
     */  
    public void unlock() {  
        //获取线程标识，判断是否一致  
        String id = ID_PREFIX + Thread.currentThread().getId();  
        String threadId = redisTemplate.opsForValue().get(prefixKey + name);  
        if (id.equals(threadId)) {  
            redisTemplate.delete(prefixKey + name);  
        }  
    }}
```
### 6、带来新的问题
![[Pasted image 20250827110222.png]]
### 7、Lua解决多条命令原子性问题
	功能：在一个脚本中编写多条Redis命令，确保多条命令执行的原子性。
	基础语法

![[Pasted image 20250827124535.png]]
#### 代码实现
	lua脚本
```lua
---  
--- Generated by EmmyLua(https://github.com/EmmyLua)  
--- Created by mzc.  
--- DateTime: 2025/8/27 13:04  
---  
if(redis.call('get',KEYS[1])==ARGV[1])then  
    --释放锁，del key  
    return redis.call('del',KEYS[1])  
end  
return 0
```
	utils
	知识点
		Collections.singletonList（）:单参数组成list
		execute：在java中操作redis调用Lua脚本
```java
/**  
 * 释放锁  
 */  
public void unlock() {  
    //调用Lua脚本  
    redisTemplate.execute(  
            UNLOCK_SCRIPT,  
            Collections.singletonList(prefixKey + name),//keys的参数  
            ID_PREFIX+Thread.currentThread().getId() //argv的参数  
            );  
}
```
	Service层保持不变
### 8、之前代码的不足
![[Pasted image 20250827142411.png]]

## 9、Redisson
---
### （1）定义
	Redisson 是一个在 Redis 的基础上实现的 Java 驻内存数据网格客户端（In-Memory Data Grid）。它不仅提供了一系列的 redis 常用数据结构命令服务，还提供了许多分布式服务，例如分布式锁、分布式对象、分布式集合、分布式远程服务、分布式调度任务服务等等
### （2）基本实现
	坐标导入
```xml
<!--Redisson-->  
<dependency>  
    <groupId>org.redisson</groupId>  
    <artifactId>redisson</artifactId>  
    <version>3.50.0</version>  
</dependency>  
  
<!--Netty 高版本的Redisson需要这个-->  
<dependency>  
    <groupId>io.netty</groupId>  
    <artifactId>netty-transport-native-unix-common</artifactId>  
    <version>4.1.79.Final</version>  
</dependency>
```
	配置类
```java
@Configuration  
public class RedisConfig {  
    @Bean  
    public RedissonClient redissonClient(){  
        //配置类  
        Config config=new Config();  
        //添加Redis的地址，这里是单机，可以是集群  
        config.useSingleServer().setAddress("redis://192.168.88.130:6379");  
        //创建客户端  
        return Redisson.create(config);  
    }  
}
```
	Service
```java
    /**  
     * 下单秒杀券  
     * @param voucherId  
     * @return  
     */  
    public Result secKillVoucher(Long voucherId) throws InterruptedException {  
        //1、查询优惠券信息  
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);  
        //2、判断是否在秒杀期间  
        if(voucher.getBeginTime().isAfter(LocalDateTime.now())||voucher.getEndTime().isBefore(LocalDateTime.now())){  
            return Result.fail("不在秒杀时间范围内");  
        }  
        //3、判断库存是否充足  
        if(voucher.getStock()<1){  
            return Result.fail("库存不足");  
        }  
        Long userId = UserHolder.getUser().getId();  
//        //创建锁对象  
//        SimpleRedisLock redisLock = new SimpleRedisLock("order:" + userId, redisTemplate);  
//        //获取锁  
//        boolean isLock = redisLock.tryLock(1200);  
        //获取锁（可重入），指定锁的名称  
        RLock lock = redissonClient.getLock("lock:order:" + userId);  
        //尝试获取锁，参数分别为：最大等待获取时间，锁自动释放时间，时间单位  
        //参数默认值：-1（失败不等待） 30秒后自动释放  
        boolean isLock = lock.tryLock();  
        //判断是否获取锁成功  
        if(!isLock){  
            //获取锁失败，返回错误信息或重试  
            return Result.fail("一人一单");  
        }  
        try {  
            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();  
            return proxy.createVoucherOrder(voucherId,userId);  
        } finally {  
            lock.unlock();  //一定要释放锁  
        }  
    }
```
### (3)可重入锁原理
#### 流程展示
![[Pasted image 20250827151303.png]]
#### 获取锁（Lua脚本）

![[Pasted image 20250827151457.png]]
#### 释放锁（Lua脚本）
![[Pasted image 20250827151651.png]]
