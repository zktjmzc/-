---
date: 2025-08-29
aliases:
  - 黑马Redis
tags:
---
## Redis消息队列
---
### 1、消息队列
	定义：存放消息的队列。
	Redis中的消息队列
		List结构：list结构模仿消息队列
		PubSub：基于点对点消息模型
		Stream：比较完善的消息队列
### 2、基于List结构模仿消息队列
	语法：
		brpop、blpop 监听时间：监听阻塞队列
		存入的语法不变，即lpush、rpush
	优点：
		不受JVM大小的限制
		基于Redis数据持久化，保障数据安全
		可以保障消息的有序性
	缺点：
		无法避免消息丢失
		只支持单消费者：一个消费者取走后，其它消费者无法获取
### 3、基于PubSub的消息队列
	原理：消费者可以订阅一个或多个Channel，生产者像Channel发送消息，订阅的所有消费者都能接收
	优点
		采用发布订阅模型，支持多生产、多消费
	缺点：
		不支持数据持久化
		无法避免消息丢失
		消息堆积有上限，超出时数据丢失
	语法

![[Pasted image 20250829093244.png]]
	通配符包括下图这些
![[Pasted image 20250829093647.png]]
### 4、基于Stream的消息队列---单消费者
	定义：可以支持一个功能完善的消息队列
	带来的问题：消息漏读，当消费者处理消息时，生产者发来多条消息，消费者只能接收到最新的消息。
	优势：可回溯、内被多消费者读取、可以阻塞读取。
	语法：
添加消息
![[Pasted image 20250829094859.png]]
读取消息
![[Pasted image 20250829095316.png]]
### 5、基于Stream的消息队列---消费者组
	消费者组：多个消费者组成，共同监听一个队列
	语法：
		创建消费者组：xgroup create key groupname ID [mkstream]
				key：队列名称
				groupname：组名称
				ID：其实ID标识，$从队列中的最后一个消息，0从队列起始开始
				mkstream：没有该消息组时，创建该消息组
		删除消费者组：xgroup destroy key groupname
		添加消费者：xgroup createconsumer key groupname consumername
		删除消费者：xgroup delconsumer key groupname consumername
		提交：xack key group ID
	需要加前缀的的命令有：
					单消费者读消息：xread
					消费者组读消息：xreadgroup

		读取消息：

![[Pasted image 20250829103032.png]]
	获取阻塞队列
![[Pasted image 20250829103950.png]]
特点
![[Pasted image 20250829101923.png]]
![[Pasted image 20250829104550.png]]
## 基于Redis的Stream结构作为消息队列，实现异步秒杀下单
---
### 代码展示
	先在Redis中创建消费者组
```c
xgroup create stream.orders g1 mkstream
```
	修改异步秒杀的Lua脚本(添加消息到消息队列)
```lua
local stockKey = 'seckill:stock:' .. voucherId  
--2.2 订单key  
local orderKey = 'seckill:order:' .. voucherId  
  
--3、脚本业务  
--3.1 判断库存是否充足get stockKey  
if (tonumber(redis.call('get', stockKey)) <= 0) then  
    --3.2 库存不足,返回1  
    return 1  
end  
--3.2 判断用户是否下单  
if (redis.call('sismember', orderKey, userId) == 1) then  
    --存在说明是重复下单  
    return 2  
end  
--3.3扣库存 incrby stockKey-1redis.call('incrby',stockKey,-1)  
--3.4添加用户 sadd orderKey userIdredis.call('sadd',orderKey,userId)  
--3.5发送消息到消息队列  
redis.call('xadd','stream.orders','*','voucherId',voucherId,'userId',userId,'id',orderId)  
return 0
```
	异步下单秒杀卷
```java
    @Autowired  
    private ISeckillVoucherService seckillVoucherService;  
  
    private final SnowflakeIdWorker snowflakeIdWorker=new SnowflakeIdWorker(29,20);  
  
    @Autowired  
    private RedisIdWorker redisIdWorker;  
  
    @Autowired  
    private StringRedisTemplate redisTemplate;  
  
    @Autowired  
    private RedissonClient redissonClient;  
  
    private static final DefaultRedisScript<Long> SECKILL_SCRIPT;  
    static {  
        SECKILL_SCRIPT =new DefaultRedisScript<>();  //在代码快中初始化，只需要初始化一次，提高性能  
        SECKILL_SCRIPT.setLocation(new ClassPathResource("seckill.lua")); //脚本加载位置  
        SECKILL_SCRIPT.setResultType(Long.class);  //返回值的结果类型  
    }  
    //添加阻塞队列（当队列中没有元素，线程会进入阻塞）  
//    private BlockingQueue<VoucherOrder> orderTasks=new ArrayBlockingQueue<>(1024*1024);  
    //创建线程池(单线程)  
    private static final ExecutorService SECKILL_ORDER_EXECUTOR= Executors.newSingleThreadExecutor();  
  
    @PostConstruct   //注解：一但该类初始化完成就会执行该方法  
    private void init(){  
        SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());  
    }  
    //内部类，设置线程任务  
    private class VoucherOrderHandler implements Runnable{  
  
        @Override  
        public void run() {  
            while (true){  
                //1、获取消息队列中的订单信息  
                try {  
                    //判断消息获取是否成功 xreadgroup group g1 c1 count 1 stock 2000 >                    List<MapRecord<String, Object, Object>> list = redisTemplate.opsForStream().read(  
                            Consumer.from("g1", "c1"),  //c1消费者名称，暂时固定  
                            //获取1个，最多阻塞2秒  
                            StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)),  
                            //lastConsumed: 代表 >                            //latest：代表 $                            StreamOffset.create("stream.orders", ReadOffset.lastConsumed())  
                    );  
                    //没有获取消息，继续尝试获取  
                    if(list==null||list.isEmpty()){  
                        continue;  
                    }  
                    //获取成功，开始下单  
                    //（1）解析消息中的信息  
                    MapRecord<String, Object, Object> record = list.get(0);  
                    Map<Object, Object> value = record.getValue();  
                    VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);  
                    //2、创建订单  
                    handleVoucherOrder(voucherOrder);  
                    //3、ACK确认  ack stream.orders g1 id                    redisTemplate.opsForStream().acknowledge("stream.orders","g1",record.getId());  
                } catch (Exception e) {  
                    log.error("处理订单异常",e);  
                    //消息没有进行提交，在pendingList中，因此处理pendingList中的消息  
                    handlePendingList();  
                }  
            }  
        }  
    }  
  
  
    private void handlePendingList(){  
        while (true){  
            //1、获取pendingList中的订单信息  
            try {  
                //判断消息获取是否成功 xreadgroup group g1 c1 count 1 streams stream.orders 0                List<MapRecord<String, Object, Object>> list = redisTemplate.opsForStream().read(  
                        Consumer.from("g1", "c1"),  //c1消费者名称，暂时固定  
                        //获取1个，最多阻塞2秒  
                        StreamReadOptions.empty().count(1),  
                        //lastConsumed: 代表 >                        //latest：代表 $                        StreamOffset.create("stream.orders", ReadOffset.from("0"))  
                );  
                //没有获取到消息，结束循环  
                if(list==null||list.isEmpty()){  
                    break;  
                }  
                //获取成功，开始下单  
                //（1）解析消息中的信息  
                MapRecord<String, Object, Object> record = list.get(0);  
                Map<Object, Object> value = record.getValue();  
                VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);  
                //2、创建订单  
                handleVoucherOrder(voucherOrder);  
                //3、ACK确认  ack stream.orders g1 id                redisTemplate.opsForStream().acknowledge("stream.orders","g1",record.getId());  
            } catch (Exception e) {  
                log.error("处理pendingList异常",e);  
                try {  
                    Thread.sleep(20);  
                } catch (InterruptedException ex) {  
                    throw new RuntimeException(ex);  
                }  
            }  
        }  
    }  
  
    private void handleVoucherOrder(VoucherOrder order) {  
        Long userId = order.getUserId();  
        //获取锁（可重入），指定锁的名称  
        RLock lock = redissonClient.getLock("lock:order:" + userId);  
        //尝试获取锁，参数分别为：最大等待获取时间，锁自动释放时间，时间单位  
        //参数默认值：-1（失败不等待） 30秒后自动释放  
        boolean isLock = lock.tryLock();  
        //判断是否获取锁成功  
        if(!isLock){  
            //获取锁失败，返回错误信息或重试  
            log.error("不允许重复下单");  
        }  
        try {  
            proxy.createVoucherOrder(order);  
        } finally {  
            lock.unlock();  //一定要释放锁  
        }  
    }  
    private IVoucherOrderService proxy;  
  
    /**  
     * 下单秒杀券  
     * @param voucherId  
     * @return  
     */  
    public Result secKillVoucher(Long voucherId) throws InterruptedException {  
        Long userId = UserHolder.getUser().getId();  
        //订单id  
        long orderId = redisIdWorker.nextId("order");  
        //1、执行Lua脚本  
        //查询商品是否还有存量，用户是否一人一单  
        Long result = redisTemplate.execute(  
                SECKILL_SCRIPT,  
                Collections.emptyList(), //没有key，传空  
                voucherId.toString(),  
                userId.toString(),  
                String.valueOf(orderId)  
        );  
        //2、判断是否有购买资格  
        int num = result != null ? result.intValue() : 0;  
        if(num!=0){  
            return Result.fail(num==1?"库存不足":"一人一单");  
        }  
        //获取代理对象  
        proxy = (IVoucherOrderService) AopContext.currentProxy();  
        //4、返回订单Id  
        return Result.ok(orderId);  
    }
```