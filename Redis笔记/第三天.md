---
date: 2025-07-24
aliases:
  - 黑马Reids[19-22]
tags:
  - RedisTemplate
  - RedisSerializer
  - StringRedisTemplate
---
## RedisTemplate
---
#### 1、添加依赖
```xml
<!--pom.xml-->

<dependencies>  
    <dependency>  
       <groupId>org.springframework.boot</groupId>  
       <artifactId>spring-boot-starter-web</artifactId>  
    </dependency>  
  
       <dependency>           <groupId>org.springframework.boot</groupId>  
           <artifactId>spring-boot-starter-data-redis</artifactId>  
       </dependency>  
  
       <dependency>           <groupId>org.apache.commons</groupId>  
           <artifactId>commons-pool2</artifactId>  
       </dependency>  
  
       <dependency>           <groupId>redis.clients</groupId>  
           <artifactId>jedis</artifactId>  
       </dependency>  
  
    <dependency>       <groupId>org.springframework.boot</groupId>  
       <artifactId>spring-boot-starter-test</artifactId>  
       <scope>test</scope>  
    </dependency>  
</dependencies>
```

#### 2、添加配置
```yaml
spring:  
  application:  
    name:redis-demo  
  
  data:  
    redis:  
      host: 192.168.88.130  
      port: 6379  
      connect-timeout: 5s  
      timeout: 5s  
      client-type: jedis  
      lettuce:  
        pool:  
          enabled: true  
          min-idle: 0  
          max-idle: 8  
          max-active: 8  
          max-wait: 5s
```

#### 3、编写测试类
```java
@SpringBootTest  
class RedisDemoApplicationTests {  
  
    @Autowired  
    private RedisTemplate<String,String>redisTemplate;  
  
    @Test  
    void contextLoads() {  
       redisTemplate.opsForValue().set("num","孟子楚");  
    }  
}
```

### 4、RedisSerializer
	概念：RedisTemplate可以接受任意的Object作为值直接写入Redis中，只不过写入前会将Object序列
	     化，默认采用JDK的序列化
	缺点：可读性差、内存占用大，不能够显示字符串的原文
#### （1）添加并自定义序列化
```java
@Configuration  
public class RedisConfig {  
  
    @Bean  
    public RedisTemplate<String, Object>redisTemplate(RedisConnectionFactory redisConnectionFactory){  
//        创建RedisTemplate对象、  
        RedisTemplate<String, Object> stringObjectRedisTemplate = new RedisTemplate<>();  
//        设置连接工厂  
        stringObjectRedisTemplate.setConnectionFactory(redisConnectionFactory);  
//        创建JSON的序列化工具  
        GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer();  
//        设置key的序列化  
        stringObjectRedisTemplate.setKeySerializer(RedisSerializer.string());  
        stringObjectRedisTemplate.setHashKeySerializer(RedisSerializer.string());  
//        设置value的序列化  
        stringObjectRedisTemplate.setValueSerializer(jsonRedisSerializer);  
        stringObjectRedisTemplate.setValueSerializer(jsonRedisSerializer);  
//        返回  
        return stringObjectRedisTemplate;  
    }  
}
```

#### （2）测试
```java
    @Test  
    void testSaveUser(){  
//     写入数据  
       redisTemplate.opsForValue().set("user:100",new User("王五",18));  
//     获取数据  
       User user = (User)redisTemplate.opsForValue().get("user:100");  
        System.out.println(user.toString());  
    }
```

### 5、StringRedisTemplate
	概念：第4个只是点配置的自定义自动序列化器存在内存占用的问题，因此，需要对于Java对象手动序列
		化，此时StringRedisTemplate默认为键值都为String，就很好利于使用

```java
    @Autowired  
    private StringRedisTemplate stringRedisTemplate;  
    private static final ObjectMapper mapper=new ObjectMapper();  
  
    @Test  
    void testSaveUser() throws JsonProcessingException {  
       User user=new User("赵六",16);  
//     序列化  
       String json = mapper.writeValueAsString(user);  
       stringRedisTemplate.opsForValue().set("person",json);  
  
       String s = stringRedisTemplate.opsForValue().get("person");  
//     反序列化  
       User user1 = mapper.readValue(s, User.class);  
       System.out.println(user1.toString());  
    }  
  
//  测试其它的数据类型  
    @Test  
    public void dummy() {  
       stringRedisTemplate.opsForHash().put("people","name","孟子楚");  
       stringRedisTemplate.opsForHash().put("people","age","21");  
       Map<Object, Object> people = stringRedisTemplate.opsForHash().entries("people");  
       for (Map.Entry<Object, Object> e : people.entrySet()) {  
          System.out.println("key："+e.getKey()+",value:"+e.getValue());  
       }  
    }
```



