---
date: 2025-09-06
aliases:
  - 面试八股文
---
# 面试八股文
---
### 一、Java基础知识
#### （1）Integer和int有什么区别？
	1、Integer默认为null，int默认为0
	2、Integer存放在堆里，int存放在栈里
	3、Integer是对象类型，封装了很多方法和属性，使用起来更加灵活
#### （2）100等于100为true，1000等于1000false
	1、对于Integer类型，Java对-128~127做了缓存，当在这个范围内，则取的是同一个对象
	2、1000超过了IntegerCache范围，则是两个不同的对象，因为==比较的是地址，
	3、解决方法：使用.equals()或者先拆箱再比较
#### （3）String、StringBuilder、StringBuffer的区别
	String性能最低，每个对象都是final，需要反复创建对象
	StringBuffer次之，每创建一个都要加锁，线程安全
	StringBuilder性能最好，线程不安全，单线程首选
#### （4）深克隆和浅克隆
	1、浅克隆：只是复制对象本身及基本字段，对于引用类型字段，只是复制了引用地址，没有复制引用对象
			结果：原对象和克隆对象的引用类型使用的是同一块内存
	2、深克隆：不仅复制了对象本身和基本字段，还递归的复制了引用类型字段，克隆对象和原对象完全独立
			结果：性能较慢
#### （5）4种对象引用
	强引用：永远不会被GC回收，即使内存不够，也只会抛出outOfMemoryError
		几乎所有变量都是强引用
	软引用：当内存足够时不会被回收，紧张会进行回收
		适合做缓存
	弱引用：只要GC运行，就一定会被回收
		避免内存泄漏：比如 `ThreadLocal` 中的 key 就是弱引用
	虚引用：不会用来获取对象
		主要在对象回收前，接收系统通知
#### （6）空Object对象占用的内存
	在HotSpot虚拟机中，对象采用的是OPP结构，组成包括对象头、实例数据、对其补充
	对象头组成：Markword（8字节）、类元指针（压缩4字节，默认8字节）、数组长度（4字节）
	对齐填充：在JVM中，java对象大小是8字节或8字节倍数来对齐，保证cpu完成一次总线操作。
			未对齐访问可能导致cpu拆成多次内存读写，性能下降
	总结：如果采用压缩指针，则是Markword+未压缩类元指针+对齐填充=16字节
		未采用压缩指针，则是Markword+压缩类元指针=16字节
#### （7）为什么重写.equal（）一定要重写HashCode（）方法
	在Java中，.equal和HashCode是绑定在一起的契约，共同服务基于哈希的数据结构
	Java规范：
		equal相等，那么HashCode必须相等
		HashCode不相同，那么一定不相同
		HashCode相同，它们不一定相同（哈希冲突）
	举例，（1）只重写equal（），则该方法返回的是true，但是两个对象存放的位置一般不同，出现了逻
			错误
		（2）反过来，HashCode重写，equal不重写，两者存放的位置是相同的，即逻辑上相同，但是由于
			equal不同，例如，HashSet可能存入相同的元素，违反了规则
	总结：HashCode判断两个对象逻辑上是否相同，equal比较的是元素值是否相同
#### （8）什么是受检异常和非受检异常
		受检异常指的是需要try/catch捕获或throws抛出，否则程序无法运行，除了Error和
		RuntimeExpection，一个是硬件上的异常，另一个是运行时异常，在运行时才能检验
		而受检异常往往是不可预知的错误，一旦出现错误会占用资源，导致程序出现问题。
#### （9）fail-fast和fail-safe
	fail-fast表示快速失败，例如，在使用迭代器遍历集合的时候，另一个线程对于集合数据进行修改，会
	立刻报错，java.util中的所有集合类都是fail-fast类型
	fail-safe表示失败安全，如果发生数据的修改，不会报错，因为其遍历的不是集合本身，采用该机制的
	集合容器遍历的时候不会直接遍历集合本身，而是复制一份，遍历复制的那一份
#### （10）序列化和反序列化
	解决网络传输中对象传输的问题，序列化就是将对象转化为字节流的方式进行存储和传输
	反序列化就是将文件或网络中获得的字节流转化为对象
	前提是保障保障通信双方对于对象的可识别性，实现跨平台、跨语言
	常用的格式：JSON、XML等
	选择标准：序列化后的大小、序列化的性能、技术成熟度、是否支持跨平台和跨语言
#### （11）内存溢出和内存泄漏
	内存溢出：是指JVM可用的内存空间不够支持创建对象的大小。
	内存泄漏：在内存中有两个大小为1MB的对象，在使用完后，并没有被释放；后面创建，使用完对象后也不
			释放，久而久之JVM的内存被占满，出现内存溢出。